# Phase 2.1: Token Utility Mechanism Specifications

## Overview

This document contains protocol-level specifications for 5 token utility mechanisms (2 enhancements + 3 new), each ready for Phase 3 implementation.

---

## PROTOCOL SPECIFICATION: M001-ENH

### Credit Class Approval Voting Enhancement

#### Purpose
Enhance the existing credit class creator allowlist mechanism with tiered approval thresholds, automated pre-screening by agents, and expedited paths for low-risk proposals.

#### Participants

**Pre-PoA (current PoS model)**:
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Proposer | Credit class creator seeking allowlist | Deposit: 1,000 REGEN |
| Validators | Block producers (capital-weighted) | Staked REGEN |
| Delegators | Token holders | Delegated REGEN |
| Registry Agent | Autonomous pre-screener | Service bond: 10,000 REGEN |

**Post-PoA (after M014 activation)**:
| Role | Description | Governance Weight |
|------|-------------|-------------------|
| Proposer | Credit class creator seeking allowlist | Deposit: 1,000 REGEN |
| Authority Validators | Curated validator set (15-21) | Equal vote weight per validator |
| Token Holders | $REGEN holders (non-validator) | Contribution-weighted (via M015 activity scores) |
| Registry Agent | Autonomous pre-screener | Service bond: 10,000 REGEN |

> **PoA Transition Note**: Under M014, the voting model changes from capital-weighted (1 REGEN = 1 vote) to a hybrid model where authority validators have equal governance weight among themselves, and token-holder participation uses contribution-weighted scoring. See §PoA Impact below for tally logic changes.

#### Token Flows
```
┌─────────────┐     deposit      ┌──────────────┐
│  Proposer   │ ────(1000)────→  │ Escrow Pool  │
└─────────────┘                  └──────────────┘
                                        │
       ┌────────────────────────────────┼────────────────────────────────┐
       │ APPROVED                       │ REJECTED                       │ EXPIRED
       ▼                                ▼                                ▼
┌──────────────┐              ┌──────────────┐              ┌──────────────┐
│  Proposer    │              │ Community    │              │  Proposer    │
│  (refund)    │              │ Pool (slash) │              │  (refund-fee)│
└──────────────┘              └──────────────┘              └──────────────┘
```

#### State Transitions
```
States: {DRAFT, AGENT_REVIEW, VOTING, APPROVED, REJECTED, EXPIRED}

DRAFT → AGENT_REVIEW
  trigger: proposer.submit(deposit=1000)
  guard: proposer.balance >= 1000
  action: escrow.lock(1000)

AGENT_REVIEW → VOTING
  trigger: agent.score >= 0.7 OR timeout(24h)
  guard: none
  action: governance.create_proposal()

AGENT_REVIEW → REJECTED
  trigger: agent.score < 0.3 AND agent.confidence > 0.9
  guard: human_override_window_expired(6h)
  action: escrow.slash(50%), escrow.refund(50%)

VOTING → APPROVED
  trigger: tally.yes_ratio > 0.5 AND quorum_met
  guard: voting_period_complete
  action: allowlist.add(proposer), escrow.refund(1000)
  poa_variant: see §PoA Impact for modified tally

VOTING → REJECTED
  trigger: tally.yes_ratio <= 0.5 OR veto > 0.334
  guard: voting_period_complete
  action: escrow.slash(200), escrow.refund(800)
  poa_variant: see §PoA Impact for modified tally
```

#### Security Invariants
1. **Deposit Conservation**: `sum(deposits) = sum(refunds) + sum(slashes) + escrow.balance`
2. **Agent Authority Bound**: Agent can only recommend; cannot directly approve/reject without human override window
3. **Governance Supremacy**: Human vote always overrides agent recommendation
4. **Slash Cap**: Maximum slash = 50% of deposit per proposal
5. **PoA Validator Parity**: Under M014, no single authority validator's vote counts more than any other validator's vote (equal weight per validator)

#### Automation Logic
```yaml
agent_pre_screening:
  inputs:
    - methodology_document: IRI
    - credit_type: string
    - admin_address: bech32
  checks:
    - methodology_completeness: [additionality, baseline, MRV, permanence]
    - credit_type_validity: must exist in allowed_credit_types
    - admin_reputation: historical proposal success rate
    - duplicate_detection: cosine_similarity < 0.85 vs existing classes
  scoring:
    weight_methodology: 0.4
    weight_reputation: 0.3
    weight_novelty: 0.2
    weight_completeness: 0.1
  output:
    score: float[0,1]
    confidence: float[0,1]
    recommendation: APPROVE | REJECT | MANUAL_REVIEW
    rationale: string
```

#### PoA Impact (M014 Transition)

When M014 (Authority Validator Governance) is activated, M001-ENH voting mechanics change significantly:

```yaml
poa_voting_model:
  description: >
    Under PoA, the credit class allowlist vote transitions from capital-weighted
    to a dual-track voting model. This preserves broad token-holder participation
    while recognizing the curated validator set's governance authority.

  tally_logic:
    # Track 1: Authority Validator Vote (weighted 60%)
    validator_track:
      eligible_voters: active_authority_validators  # 15-21 from M014
      weight_per_validator: 1 / active_validator_count  # equal weight
      threshold: simple_majority (> 50%)
      quorum: 2/3 of active validators must vote

    # Track 2: Token-Holder Vote (weighted 40%)
    holder_track:
      eligible_voters: all REGEN holders (excluding validator operational addresses)
      weight: contribution_score (from M015) OR 1-token-1-vote (pre-M015)
      threshold: simple_majority (> 50%)
      quorum: 10% of circulating supply participating

    # Combined Tally
    approval_condition: >
      (validator_track.approved AND holder_track.approved)
      OR (validator_track.approved with >= 75% supermajority)
      OR (holder_track.approved with >= 75% supermajority AND validator_track.quorum_met)

    veto_condition: >
      validator_veto > 33.4% OR holder_veto > 33.4%
      (either track can veto; preserves minority protection)

  rationale: >
    The 60/40 weighting reflects that authority validators have demonstrated
    commitment through the M014 selection process, while ensuring token holders
    retain meaningful governance voice. Either track achieving supermajority
    can carry a proposal, preventing gridlock while maintaining checks.

  transition_period:
    phase_1: "M014 active but M001-ENH uses legacy tally (backward compat)"
    phase_2: "Dual-track tally activated via governance proposal"
    phase_3: "Contribution-weighted holder track (requires M015 active)"

  open_questions:
    - "OQ-M001-1: Is 60/40 the right validator-to-holder weight split? Should registry-specific proposals weight ecological data steward validators higher?"
    - "OQ-M001-2: Should the agent pre-screening score influence which governance track is required? E.g., high-confidence agent approvals could use a lighter-touch validator-only fast track."
```

#### Implementation Notes
- **Module**: Extend `x/ecocredit` with `MsgProposeClassCreator`
- **Storage**: New `ClassCreatorProposal` object with agent scores
- **Events**: `EventClassCreatorProposed`, `EventAgentScoreSubmitted`
- **Migration**: Backward compatible; existing allowlist preserved. PoA tally logic activated via governance proposal after M014 goes live.
- **Dependencies**: KOI MCP for methodology analysis, Ledger MCP for state queries, M014 (for PoA tally variant), M015 (for contribution-weighted holder votes)

---

## PROTOCOL SPECIFICATION: M008

### Data Attestation Bonding

#### Purpose
Create economic incentives for high-quality ecological data attestations by requiring attesters to bond REGEN tokens that can be slashed for false or misleading claims.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Attester | Entity making ecological claims | Bond: varies by claim type |
| Challenger | Entity disputing attestation | Challenge deposit: 10% of bond |
| Arbiter DAO | Resolution body (subDAO) | Staked in arbiter pool |
| Beneficiary | Project receiving attestation | None |

#### Token Flows
```
┌─────────────┐     bond         ┌──────────────┐
│  Attester   │ ────(B)────────→ │ Attestation  │
└─────────────┘                  │ Bond Pool    │
                                 └──────────────┘
                                        │
       ┌────────────────────────────────┼────────────────────────────────┐
       │ UNCHALLENGED (lock_period)     │ CHALLENGED                     │
       ▼                                ▼
┌──────────────┐              ┌──────────────┐
│  Attester    │              │ Arbiter DAO  │
│  (refund+    │              │ Resolution   │
│   yield)     │              └──────┬───────┘
└──────────────┘                     │
                    ┌────────────────┼────────────────┐
                    │ ATTESTER WINS  │ CHALLENGER WINS│
                    ▼                ▼
              ┌──────────────┐ ┌──────────────┐
              │ Attester:    │ │ Challenger:  │
              │ bond+chal_dep│ │ bond+arb_fee │
              └──────────────┘ │ Arbiter: fee │
                               │ CommunityPool│
                               │ : remainder  │
                               └──────────────┘
```

#### State Transitions
```
States: {BONDED, ACTIVE, CHALLENGED, RESOLVED_VALID, RESOLVED_INVALID, RELEASED}

Initial → BONDED
  trigger: attester.bond(amount, attestation_iri)
  guard: amount >= min_bond[attestation_type]
  action: bond_pool.lock(amount), attestation.create()

BONDED → ACTIVE
  trigger: activation_delay_passed(48h)
  guard: no_challenge_submitted
  action: attestation.activate()

ACTIVE → CHALLENGED
  trigger: challenger.submit_challenge(evidence_iri, deposit)
  guard: deposit >= bond * 0.1, within_challenge_window
  action: challenge_pool.lock(deposit), attestation.pause()

CHALLENGED → RESOLVED_VALID
  trigger: arbiter_dao.vote(VALID)
  guard: quorum_met, voting_complete
  action: attester.receive(bond + challenge_deposit - arbiter_fee)

CHALLENGED → RESOLVED_INVALID
  trigger: arbiter_dao.vote(INVALID)
  guard: quorum_met, voting_complete
  action: challenger.receive(bond * 0.5 + deposit - arbiter_fee),
          community_pool.receive(bond * 0.5)

ACTIVE → RELEASED (after lock_period)
  trigger: lock_period_expired AND no_active_challenge
  action: attester.receive(bond + yield)
```

#### Bond Schedule by Attestation Type
| Attestation Type | Min Bond (REGEN) | Lock Period | Challenge Window |
|------------------|------------------|-------------|------------------|
| Project Boundary | 500 | 90 days | 60 days |
| Baseline Measurement | 1,000 | 180 days | 120 days |
| Credit Issuance Claim | 2,000 | 365 days | 300 days |
| Methodology Validation | 5,000 | 730 days | 600 days |

#### Security Invariants
1. **Bond Coverage**: `attestation.value_at_risk <= bond * coverage_ratio`
2. **Challenge Skin-in-Game**: Challengers must deposit to prevent spam
3. **Arbiter Neutrality**: Arbiters cannot be attester/challenger/beneficiary
4. **Slash Distribution**: Slashed bonds split between challenger (50%) and community pool (50%)

#### Implementation Notes
- **Module**: New `x/attestation` module or extend `x/data`
- **Storage**: `Attestation`, `Bond`, `Challenge`, `Resolution` objects
- **CosmWasm**: Arbiter DAO as DAO DAO subDAO contract
- **Dependencies**: IRI resolution for evidence, KOI for cross-referencing

---

## PROTOCOL SPECIFICATION: M009

### Service Provision Escrow

#### Purpose
Enable trustless engagement of ecosystem services (verification, monitoring, methodology development) with milestone-based payment release and dispute resolution.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Client | Service requester (project developer, class admin) | Escrow amount |
| Provider | Service deliverer (verifier, MRV operator, methodology author) | Service bond: 10% of escrow |
| Arbiter | Dispute resolver (M008 Arbiter DAO) | Staked in arbiter pool |
| AGENT-001 | Automated milestone evidence reviewer | Service bond: 10,000 REGEN |
| AGENT-003 | Market price fairness monitor | Service bond: 5,000 REGEN |

#### Token Flows
```
┌─────────────┐     escrow       ┌──────────────┐    service_bond   ┌──────────────┐
│   Client    │ ────(E)────────→ │   Escrow     │ ←────(0.1E)────── │   Provider   │
└─────────────┘                  │   Contract   │                   └──────────────┘
                                 └──────────────┘
                                        │
       ┌───────────────────┬────────────┼────────────────────────────────┐
       │ MILESTONE         │ DISPUTED   │                                │ CANCELLED
       │ APPROVED          │            │ COMPLETED                      │ (pre-start)
       ▼                   ▼            ▼                                ▼
┌──────────────┐  ┌──────────────┐  ┌──────────────┐           ┌──────────────┐
│  Provider    │  │ Arbiter      │  │ Provider:    │           │ Client:      │
│  (milestone  │  │ Resolution   │  │  bond refund │           │  escrow      │
│   payment)   │  └──────┬───────┘  │ Platform fee:│           │  refund -    │
└──────────────┘         │          │  1% of escrow│           │  cancellation│
                ┌────────┼────────┐ └──────────────┘           │  fee (2%)    │
                │ CLIENT │PROVIDER│                             │ Provider:    │
                │ WINS   │ WINS   │ SPLIT                      │  bond refund │
                ▼        ▼        ▼                             └──────────────┘
          ┌────────┐ ┌────────┐ ┌────────────┐
          │Client: │ │Provdr: │ │Client: X%  │
          │remaining│ │escrow+ │ │Provdr:     │
          │escrow - │ │bond -  │ │ (100-X)%   │
          │arb_fee  │ │arb_fee │ │- arb_fee   │
          │Provdr:  │ │Client: │ └────────────┘
          │slashed  │ │ 0      │
          │bond to  │ └────────┘
          │comm_pool│
          └────────┘
```

Token flow breakdown per resolution:
- **Milestone approved**: Provider receives `milestone.payment` from escrow. Platform fee (1% of milestone payment) to community pool.
- **Dispute → Client wins**: Client receives remaining escrow minus arbiter fee. Provider bond slashed: 50% to client as compensation, 50% to community pool.
- **Dispute → Provider wins**: Provider receives remaining escrow + bond minus arbiter fee. Client loses remaining escrow.
- **Dispute → Split**: Arbiter specifies `client_percent` (1-99). Each party receives proportional share minus arbiter fee.
- **Completed**: Provider receives bond refund. Platform fee (1% of total escrow) to community pool.
- **Cancelled (pre-start)**: Client receives escrow minus cancellation fee (2%). Provider receives full bond refund.

#### State Transitions
```
States: {PROPOSED, FUNDED, IN_PROGRESS, MILESTONE_REVIEW, COMPLETED, DISPUTED, RESOLVED, CANCELLED}

Initial → PROPOSED
  trigger: client.propose_service(spec, milestones, escrow_amount)
  guard: milestones.length >= 1 AND milestones.length <= 20
         AND sum(milestone.payments) == escrow_amount
         AND each(milestone.payment) > 0
  action: service_agreement.create(status=PROPOSED)

PROPOSED → FUNDED
  trigger: provider.accept(service_bond) AND client.fund(escrow_amount)
  guard: provider.reputation >= min_provider_reputation
         AND service_bond >= escrow_amount * provider_bond_ratio
         AND client.balance >= escrow_amount
  action: escrow.lock(escrow_amount + service_bond)

PROPOSED → CANCELLED
  trigger: client.cancel() OR provider.reject() OR timeout(acceptance_window)
  guard: state == PROPOSED (no funds locked)
  action: agreement.close(reason)

FUNDED → IN_PROGRESS
  trigger: start_date_reached OR both_parties_confirm
  action: milestone[0].activate(), agreement.started_at = now()

FUNDED → CANCELLED
  trigger: client.cancel() OR mutual_cancel()
  guard: none (funds are locked)
  action: escrow.refund(client, escrow_amount - cancellation_fee),
          escrow.refund(provider, service_bond),
          community_pool.receive(cancellation_fee)

IN_PROGRESS → MILESTONE_REVIEW
  trigger: provider.submit_deliverable(milestone_id, evidence_iri)
  guard: milestone.status == IN_PROGRESS
         AND milestone_id == current_milestone
  action: milestone.set_pending_review(),
          milestone.submitted_at = now(),
          review_deadline = now() + review_period

MILESTONE_REVIEW → IN_PROGRESS
  trigger: client.approve_milestone(milestone_id)
  guard: milestone.status == PENDING_REVIEW
  action: provider.receive(milestone.payment - platform_fee),
          community_pool.receive(platform_fee),
          milestone.status = APPROVED,
          current_milestone += 1,
          IF more_milestones THEN next_milestone.activate()

MILESTONE_REVIEW → DISPUTED
  trigger: client.dispute(milestone_id, reason, evidence_iri)
           OR timeout(review_period)
  guard: milestone.status == PENDING_REVIEW
  action: dispute.create(agreement_id, milestone_id, reason),
          arbiter.assign(from=arbiter_dao),
          agreement.freeze()

MILESTONE_REVIEW → IN_PROGRESS
  trigger: provider.revise_deliverable(milestone_id, new_evidence_iri)
  guard: milestone.status == PENDING_REVIEW
         AND revision_count < max_revisions
  action: milestone.revision_count += 1,
          milestone.deliverable_iri = new_evidence_iri,
          review_deadline = now() + review_period

DISPUTED → RESOLVED
  trigger: arbiter.resolve(resolution_type, rationale)
  guard: arbiter.is_assigned AND resolution_deadline_not_expired
  action: execute_resolution(resolution_type),
          dispute.close(rationale)
  resolution_types:
    CLIENT_WINS: escrow.return_remaining(client - arb_fee),
                 bond.slash(provider, 50%→client, 50%→community_pool)
    PROVIDER_WINS: escrow.release_remaining(provider - arb_fee),
                   bond.refund(provider)
    SPLIT(X%): escrow.split(client=X%, provider=(100-X)%, - arb_fee),
               bond.refund(provider)

RESOLVED → IN_PROGRESS
  trigger: both_parties_confirm_continuation
  guard: resolution_type != CLIENT_WINS
         AND remaining_milestones > 0
  action: resume_from_next_milestone()

RESOLVED → COMPLETED
  trigger: resolution_type == CLIENT_WINS
           OR no_remaining_milestones
           OR mutual_termination
  action: final_settlement(), agreement.close()

IN_PROGRESS → COMPLETED
  trigger: all_milestones_approved
  action: provider.receive(service_bond),
          platform_fee_final = escrow_amount * completion_fee_rate,
          community_pool.receive(platform_fee_final),
          agreement.close()
```

#### Milestone Lifecycle
```
Milestone States: {PENDING, IN_PROGRESS, SUBMITTED, APPROVED, DISPUTED, REVISED}

PENDING → IN_PROGRESS
  trigger: previous_milestone.approved OR (index == 0 AND agreement.started)

IN_PROGRESS → SUBMITTED
  trigger: provider.submit_deliverable(evidence_iri)

SUBMITTED → APPROVED
  trigger: client.approve()

SUBMITTED → DISPUTED
  trigger: client.dispute() OR timeout(review_period)

SUBMITTED → REVISED
  trigger: provider.revise(new_evidence_iri)
  guard: revision_count < max_revisions

REVISED → SUBMITTED
  trigger: automatic (re-enters review)

DISPUTED → APPROVED (via arbiter: PROVIDER_WINS or SPLIT)
DISPUTED → cancelled (via arbiter: CLIENT_WINS on final milestone)
```

#### Agent Integration
```yaml
agent_001_milestone_review:
  trigger: milestone.submitted
  workflow: WF-RR-04 (new)
  actions:
    - verify_evidence_iri_resolves(deliverable_iri)
    - assess_deliverable_quality(methodology_compliance, completeness)
    - cross_reference_prior_milestones(consistency_check)
  output:
    score: float[0,1]
    recommendation: APPROVE | NEEDS_REVISION | FLAG_FOR_CLIENT
    rationale: string
  authority: advisory_only  # client makes final approval decision

agent_003_pricing_monitor:
  trigger: agreement.created OR milestone.approved
  workflow: WF-MM-04 (new)
  actions:
    - compare_escrow_to_market_rates(service_type, scope)
    - flag_outlier_pricing(z_score > 2.5)
    - track_provider_completion_rates()
  output:
    price_fairness: float[0,1]
    provider_reliability: float[0,1]
    alerts: []Alert
  authority: advisory_only  # report to KOI dashboard
```

#### Standard Service Types
| Service Type | Typical Escrow | Milestones | Review Period | Min Provider Reputation |
|--------------|----------------|------------|---------------|------------------------|
| Project Verification | 2,000-10,000 REGEN | 3-5 | 14 days | 200 |
| Methodology Development | 10,000-50,000 REGEN | 5-10 | 21 days | 400 |
| MRV Setup | 5,000-20,000 REGEN | 4-6 | 14 days | 300 |
| Credit Issuance Support | 1,000-5,000 REGEN | 2-3 | 7 days | 100 |
| Monitoring & Reporting | 500-3,000 REGEN | 1-3 | 7 days | 100 |

#### Governance Parameters
| Parameter | Default | Range | Governor |
|-----------|---------|-------|----------|
| `provider_bond_ratio` | 10% (1000 bps) | 5-25% | Governance proposal |
| `platform_fee_rate` | 1% (100 bps) | 0-5% | Governance proposal |
| `cancellation_fee_rate` | 2% (200 bps) | 0-10% | Governance proposal |
| `min_provider_reputation` | 100 | 0-500 | Governance proposal |
| `acceptance_window` | 7 days | 1-30 days | Contract admin |
| `max_revisions` | 3 | 1-10 | Contract admin |
| `arbiter_fee_rate` | 5% of disputed amount | 1-15% | Arbiter DAO |
| `default_review_period` | 14 days | 3-30 days | Governance proposal |
| `dispute_resolution_deadline` | 21 days | 7-60 days | Arbiter DAO |

#### Security Invariants
1. **Escrow Conservation**: `escrow.balance = escrow_amount - sum(approved_milestone_payments) - sum(platform_fees) - sum(dispute_settlements)` at all times
2. **Bond Integrity**: Provider bond is locked for the entire agreement lifetime and can only be released on COMPLETED or refunded on specific CANCELLED/RESOLVED transitions
3. **Milestone Payment Bound**: `sum(milestone.payments) == escrow_amount` — no milestone can pay more than its defined amount, and the sum of all milestones exactly equals the escrowed amount
4. **Sequential Milestones**: Only `milestone[current_milestone]` can be submitted; milestones must be approved in order
5. **Arbiter Neutrality**: Dispute arbiter cannot be client, provider, or any address that has transacted with either party within 90 days (enforced by M008 Arbiter DAO conflict checks)
6. **No Double Settlement**: A dispute can only be resolved once; resolved agreements cannot be re-disputed on the same milestone
7. **Cancellation Guard**: FUNDED agreements can only be cancelled with cancellation fee; IN_PROGRESS agreements cannot be unilaterally cancelled (must dispute or mutually agree)
8. **Timeout Escalation**: If `review_period` expires without client action, the milestone auto-enters DISPUTED state to prevent indefinite blocking

#### Open Questions
- **OQ-M009-1**: Should provider reputation feed back into M010 automatically on agreement completion, or require a separate endorsement transaction?
- **OQ-M009-2**: Should partial milestone payments be supported (e.g., 70% on submission, 30% on final approval) for long-running milestones?
- **OQ-M009-3**: Under PoA (M014), should authority validators have an override capability for stuck disputes, or should all dispute resolution remain with the Arbiter DAO?
- **OQ-M009-4**: How should escrow interact with the fee routing mechanism (M013)? Should platform fees follow the M013 distribution model or have a separate path?

#### Implementation Notes
- **Module**: CosmWasm contract (`contracts/service-escrow`)
- **Storage**: `ServiceAgreement`, `Milestone`, `Dispute` objects (see Phase 3, §3.1)
- **Integration**: Link to `x/ecocredit` for credit-related services, M008 Arbiter DAO for dispute resolution, M010 for provider reputation queries
- **Events**: `EventAgreementCreated`, `EventMilestonSubmitted`, `EventMilestoneApproved`, `EventDisputeCreated`, `EventDisputeResolved`, `EventAgreementCompleted`, `EventAgreementCancelled`
- **Queries**: `QueryAgreement`, `QueryAgreementsByClient`, `QueryAgreementsByProvider`, `QueryDispute`, `QueryMilestoneStatus`
- **Dependencies**: M008 (Arbiter DAO for dispute resolution), M010 (provider reputation for acceptance guard), DAO DAO contracts

---

## PROTOCOL SPECIFICATION: M010

### Reputation/Legitimacy Signaling

> **Canonical spec**: [`mechanisms/m010-reputation-signal/SPEC.md`](../mechanisms/m010-reputation-signal/SPEC.md) — the definitive specification with full challenge workflow, schemas, and test vectors. This section provides a summary.

#### Purpose
Create a non-transferable reputation system where stakeholders can signal endorsement of entities through stake-weighted attestations, building verifiable track records. Includes a challenge/dispute workflow for contesting signals.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Subject | Entity receiving reputation signals | None |
| Signaler | Entity providing endorsement | Staked REGEN (not locked) |
| Challenger | Entity disputing a signal | Meets min_stake for category; v1: challenge deposit |
| Admin / Arbiter | Resolves challenges | v0: admin key; v1: Arbiter DAO (reuse M008) |
| Aggregator | System computing reputation scores | None |

#### Token Flows
```
Note: No token transfers occur in v0. Reputation is derived from:
1. Staked REGEN balance of signalers
2. Signaler's own reputation score
3. Historical accuracy of signaler's endorsements

Weight = S * R * decay(age) * category_relevance

v1 additions:
- Challenge deposits (10% of challenger's stake, min 100 REGEN)
- Failed challengers forfeit deposit (anti-spam)
- Successful challengers receive reward from forfeited signal bond
```

#### Signal Lifecycle State Machine
```
States: {SUBMITTED, ACTIVE, CHALLENGED, RESOLVED_VALID, RESOLVED_INVALID, WITHDRAWN, INVALIDATED}

SUBMITTED → ACTIVE
  trigger: activation_delay_passed(24h) AND no_challenge
  action: signal begins contributing to reputation score

ACTIVE → CHALLENGED
  trigger: challenger.submit_challenge(signal_id, evidence, rationale)
  guard: challenger meets min_stake, not self-challenge, within challenge_window
  action: signal contribution PAUSED

CHALLENGED → RESOLVED_VALID
  trigger: v0: admin.resolve(VALID) | v1: arbiter_dao.vote(VALID)
  action: signal contribution RESTORED

CHALLENGED → RESOLVED_INVALID
  trigger: v0: admin.resolve(INVALID) | v1: arbiter_dao.vote(INVALID)
  action: signal contribution PERMANENTLY REMOVED

ACTIVE → WITHDRAWN
  trigger: signaler.withdraw()
  guard: signal not currently CHALLENGED
  action: signal contribution removed (non-punitive)

ACTIVE → INVALIDATED
  trigger: admin.invalidate(rationale)
  action: signal contribution PERMANENTLY REMOVED; rationale published

Terminal: RESOLVED_INVALID, WITHDRAWN, INVALIDATED
```

#### Reputation Calculation
```
subject_reputation[category] =
  sum(
    for each signal in signals[subject][category]
      where signal.status IN (ACTIVE, RESOLVED_VALID):
        signal.weight * signaler.reputation * time_decay(signal.age)
  ) / normalization_factor

time_decay(age) = e^(-age / half_life)
  where half_life = 365 days

stake_factor(s) = log(1 + s / 1000) / log(1 + max_stake / 1000)
```

#### Challenge Parameters
| Parameter | v0 | v1 | Rationale |
|-----------|----|----|-----------|
| activation_delay | 24h | 24h | Window for early challenge |
| challenge_window | 180 days | 365 days | Higher stakes in v1 |
| challenge_deposit | None | 10% of stake (min 100 REGEN) | Anti-spam |
| resolution_deadline | 14 days | 21 days | Max time to resolve |
| response_window | 7 days | 10 days | Time for signaler response |

#### Reputation Categories
| Category | Min Stake | Half-Life | Use Cases |
|----------|-----------|-----------|-----------|
| Credit Class Quality | 1,000 REGEN | 2 years | Class approval, buyer confidence |
| Project Legitimacy | 500 REGEN | 1 year | Project verification priority |
| Verifier Competence | 2,000 REGEN | 3 years | Service provider selection |
| Methodology Rigor | 5,000 REGEN | 5 years | Methodology approval |

#### Security Invariants
1. **Non-Transferability**: Reputation scores cannot be bought/sold
2. **Stake Requirement**: Signals require active stake (not historical)
3. **Sybil Resistance**: Weight = f(stake, reputation), not count
4. **Accountability**: Signal history is permanent and public
5. **Challenge Integrity**: Challenged signals do not contribute to score until resolved
6. **No Self-Challenge**: A signaler cannot challenge their own signal
7. **Resolution Guarantee**: Unresolved challenges auto-escalate after `resolution_deadline`

#### Implementation Notes
- **Module**: New `x/reputation` module
- **Storage**: `Signal`, `ReputationScore`, `Challenge`, `Resolution` objects
- **Computation**: Off-chain aggregation with on-chain anchoring
- **Challenge resolution**: v0: admin; v1: Arbiter DAO (reuse M008 infrastructure)
- **Schemas**: `mechanisms/m010-reputation-signal/schemas/` (signal, challenge, KPI)

---

## PROTOCOL SPECIFICATION: M011

### Marketplace Curation & Quality Signals

#### Purpose
Enhance the existing marketplace with quality signals, curated collections, and price discovery mechanisms that surface high-integrity credits. Curators stake REGEN to create and maintain collections of vetted credit batches, earning a share of trade fees from their collections. AGENT-003 (Market Monitor) provides automated quality scoring.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Seller | Credit holder listing for sale | Listing fee: 10 REGEN |
| Buyer | Credit purchaser | Purchase amount |
| Curator | Collection creator/maintainer | Curation bond: 1,000 REGEN |
| Market Agent (AGENT-003) | Automated quality assessor | Service bond: 5,000 REGEN |
| Challenger | Disputes curator inclusion of low-quality batch | Challenge deposit: 100 REGEN |

#### Token Flows
```
                    CURATOR LIFECYCLE
┌─────────────┐     bond           ┌──────────────┐
│   Curator   │ ────(1000)───────→ │  Curation    │
└─────────────┘                    │  Bond Pool   │
      ▲                            └──────────────┘
      │ fee_share                         │
      │ (% of trade                       │
      │  fees on                  ┌───────┴──────────────────┐
      │  collection)              │ ACTIVE                    │ SLASHED
      │                           ▼                           ▼
┌─────┴────────┐           ┌──────────────┐           ┌──────────────┐
│ Curator      │           │ Bond refund  │           │ Slash to     │
│ Rewards      │           │ (on exit)    │           │ community    │
│ Pool         │           └──────────────┘           │ pool         │
└──────────────┘                                      └──────────────┘

                    TRADE FLOW (collection purchase)
┌─────────────┐     purchase       ┌──────────────┐
│   Buyer     │ ────(P)──────────→ │  Marketplace │
└─────────────┘                    └──────────────┘
                                          │
                          ┌───────────────┼────────────────┐
                          │ Seller        │ Curator        │ Protocol
                          │ (P - fees)    │ (curation_fee) │ (trade_fee)
                          ▼               ▼                ▼
                    ┌──────────┐   ┌──────────┐    ┌──────────────┐
                    │  Seller  │   │  Curator │    │ Community    │
                    └──────────┘   └──────────┘    │ Pool (M013)  │
                                                   └──────────────┘
```

Token flow breakdown:
- **Collection creation**: Curator bonds `curation_bond_amount` REGEN, locked while collection is ACTIVE.
- **Trade through collection**: Buyer pays purchase price. Seller receives `price - trade_fee - curation_fee`. Curator receives `curation_fee` (default 0.5% of trade). Protocol receives `trade_fee` (routed per M013 fee distribution).
- **Direct trade** (no collection): Standard marketplace fee only, no curator fee.
- **Curator exit**: Bond refunded after `unbonding_period` if collection has no pending challenges.
- **Curator slashed**: Bond partially or fully slashed to community pool if collection contains fraudulent/low-quality batches (proven via challenge).

#### State Transitions — Collection Lifecycle
```
States: {PROPOSED, ACTIVE, SUSPENDED, UNDER_REVIEW, CLOSED}

Initial → PROPOSED
  trigger: curator.create_collection(name, criteria, bond)
  guard: bond >= min_curation_bond
         AND criteria.is_valid()
  action: bond_pool.lock(bond), collection.create(status=PROPOSED)

PROPOSED → ACTIVE
  trigger: activation_delay_passed(48h) AND no_challenge_submitted
  action: collection.activate(), collection.accepting_members = true

ACTIVE → ACTIVE (add member)
  trigger: curator.add_to_collection(batch_denom)
  guard: batch_denom.meets_criteria(collection.criteria)
         AND batch_denom.quality_score >= min_quality_score
         AND batch_denom NOT in collection.members
  action: collection.members.add(batch_denom)

ACTIVE → ACTIVE (remove member)
  trigger: curator.remove_from_collection(batch_denom)
  guard: batch_denom IN collection.members
  action: collection.members.remove(batch_denom)

ACTIVE → UNDER_REVIEW
  trigger: challenger.challenge_inclusion(collection_id, batch_denom, evidence_iri, deposit)
           OR agent_003.flag_quality_violation(collection_id, batch_denom)
  guard: deposit >= challenge_deposit_amount (if challenger)
         AND batch_denom IN collection.members
  action: collection.pause_additions(),
          challenge.create(collection_id, batch_denom, evidence)

UNDER_REVIEW → ACTIVE
  trigger: challenge.resolved(CURATOR_WINS)
  action: challenger.slash(deposit → community_pool),
          collection.resume_additions()

UNDER_REVIEW → SUSPENDED
  trigger: challenge.resolved(CHALLENGER_WINS)
  action: collection.members.remove(offending_batch),
          curator.slash(bond * slash_percentage),
          challenger.receive(challenge_deposit + reward_from_slash),
          IF curator.bond_remaining < min_curation_bond THEN → CLOSED

SUSPENDED → ACTIVE
  trigger: curator.top_up_bond(amount) AND suspension_period_expired
  guard: curator.bond >= min_curation_bond
  action: collection.resume_additions()

SUSPENDED → CLOSED
  trigger: timeout(bond_top_up_window) OR curator.close_collection()
  action: remaining_bond.refund(curator),
          collection.deactivate()

ACTIVE → CLOSED
  trigger: curator.close_collection()
  guard: no_pending_challenges
  action: bond.schedule_refund(unbonding_period),
          collection.deactivate()
```

#### Curation Collections
```yaml
Collection:
  id: uint64
  curator: address
  name: string
  description: string
  bond: Coin
  bond_remaining: Coin
  criteria: CurationCriteria
  members: []BatchDenom
  fee_share: percentage       # curator's share of trades through collection
  status: CollectionStatus    # PROPOSED | ACTIVE | SUSPENDED | UNDER_REVIEW | CLOSED
  quality_floor: float        # minimum quality_score for inclusion
  created_at: Timestamp
  activated_at: Timestamp
  trade_volume: Coin          # cumulative trade volume
  total_rewards: Coin         # cumulative curator rewards

CurationCriteria:
  min_project_reputation: float   # from M010 reputation scores
  min_class_reputation: float     # from M010 reputation scores
  allowed_credit_types: []string  # e.g., ["carbon", "biodiversity"]
  geographic_scope: []region      # ISO 3166 country/region codes
  vintage_range: {min: year, max: year}
  min_verification_recency: duration  # e.g., "365d"
```

#### Quality Scoring Algorithm
```
quality_score = weighted_sum(
  project_reputation: 0.25,   # M010 score for the project
  class_reputation: 0.20,     # M010 score for the credit class
  vintage_freshness: 0.15,    # linear decay: 1.0 at issuance, 0.0 at 10 years
  verification_recency: 0.15, # linear decay: 1.0 at last verification, 0.0 at 3 years
  seller_reputation: 0.10,    # M010 score for the seller address
  price_fairness: 0.10,       # 1.0 at median, decaying by |deviation| from class median
  additionality_confidence: 0.05  # methodology additionality score (from credit class metadata)
)

Output: integer 0-1000

Input sources:
  - project_reputation, class_reputation, seller_reputation → M010 Reputation Registry
  - vintage_freshness → x/ecocredit batch start_date
  - verification_recency → most recent MsgCreateBatch or attestation timestamp
  - price_fairness → AGENT-003 price median tracking (WF-MM-01)
  - additionality_confidence → credit class methodology metadata IRI → KOI analysis

Price fairness calculation:
  median = class_batch_price_median(credit_type, vintage_year)
  deviation = |listing_price - median| / median
  price_fairness = max(0, 1.0 - deviation * 2)
  # e.g., 50% above/below median → 0.0, at median → 1.0, 25% off → 0.5
```

#### Agent Integration
```yaml
agent_003_marketplace_monitor:
  trigger: SellOrderCreated OR periodic(hourly)
  workflow: WF-MM-01, WF-MM-02

  quality_scoring:
    - compute_quality_score(batch_denom) on new listings
    - refresh_quality_scores(all active batches) daily
    - submit_score_to_contract(batch_denom, score, confidence, factors)

  collection_monitoring:
    - verify_members_still_meet_criteria(collection_id) daily
    - flag_quality_degradation(batch_denom, reason)
    - auto_challenge_if: quality_score < collection.quality_floor * 0.5
      AND confidence > 0.9

  market_intelligence:
    - compute_class_price_medians() hourly
    - detect_price_anomalies(z_score > 2.5) → WF-MM-01
    - generate_collection_performance_reports() weekly

  authority:
    - submit_quality_scores: autonomous (Layer 1)
    - flag_quality_violations: autonomous alert (Layer 1)
    - auto_challenge: requires human confirmation (Layer 2)
    - no_direct_removal: cannot remove batches from collections
```

#### Featured Batches
```yaml
featured_batch:
  mechanism: AGENT-003 recommendation + curator confirmation
  criteria:
    - quality_score >= 800 (top 20%)
    - no_pending_challenges
    - active_sell_orders > 0
  display:
    - featured badge on marketplace UI
    - priority placement in search results
  duration: 7 days (renewable)
  governance_layer: Layer 2 (agent recommends, curator confirms)
```

#### Governance Parameters
| Parameter | Default | Range | Governor |
|-----------|---------|-------|----------|
| `min_curation_bond` | 1,000 REGEN | 100-10,000 | Governance proposal |
| `listing_fee` | 10 REGEN | 0-100 | Governance proposal |
| `curation_fee_rate` | 0.5% (50 bps) | 0-2% | Governance proposal |
| `challenge_deposit_amount` | 100 REGEN | 10-1,000 | Governance proposal |
| `slash_percentage` | 20% of bond | 5-50% | Governance proposal |
| `challenge_reward_share` | 50% of slash | 25-75% | Governance proposal |
| `activation_delay` | 48 hours | 24h-7d | Contract admin |
| `unbonding_period` | 14 days | 7-30 days | Governance proposal |
| `bond_top_up_window` | 7 days | 3-14 days | Contract admin |
| `min_quality_score` | 300 (out of 1000) | 100-500 | Governance proposal |
| `max_collections_per_curator` | 5 | 1-20 | Contract admin |
| `quality_refresh_interval` | 24 hours | 6h-7d | Contract admin |

#### Security Invariants
1. **Bond Conservation**: `bond_pool.balance = sum(active_collection_bonds) + sum(pending_refunds)` at all times
2. **Criteria Enforcement**: Every `batch_denom` in a collection must satisfy the collection's `CurationCriteria` at the time of addition; AGENT-003 daily re-verification catches criteria drift
3. **Curator Authority**: Only the collection curator can add/remove batches; no other address (including agents) can modify collection membership directly
4. **Slash Cap**: Cumulative slashing cannot exceed the curator's total bond; if `bond_remaining < min_curation_bond` after a slash, collection transitions to CLOSED
5. **No Self-Challenge**: A curator cannot challenge their own collection; a challenger cannot be the seller of the challenged batch
6. **Fee Integrity**: Curation fees are only collected on trades executed through a collection; direct marketplace trades incur no curation fee
7. **Quality Score Immutability**: Once submitted, a quality score can only be superseded (not edited); full history preserved for audit
8. **Collection Uniqueness**: A `batch_denom` can belong to multiple collections, but each `(collection_id, batch_denom)` pair is unique

#### Open Questions
- **OQ-M011-1**: Should curators be required to hold the credit types they curate, or is the bond sufficient alignment? Requiring holdings could improve skin-in-the-game but limits curator diversity.
- **OQ-M011-2**: Should quality scores be fully on-chain (transparent but costly) or anchored on-chain with details in KOI (cheaper but requires trust in the off-chain layer)?
- **OQ-M011-3**: How should the curation fee interact with M013 fee routing? Should it be a separate fee or carved out of the existing trade fee?
- **OQ-M011-4**: Should there be a "curator reputation" tracked via M010, and should poorly-performing curators face increasing bond requirements?
- **OQ-M011-5**: How to handle basket tokens (from `x/ecocredit/basket`) in collections — should the quality score apply to the basket or to its constituent batches?

#### Implementation Notes
- **Module**: CosmWasm contract (`contracts/marketplace-curation`) extending `x/ecocredit/marketplace`
- **Storage**: `Collection`, `QualityScore`, `CurationBond`, `Challenge` objects (see Phase 3, §3.1)
- **Events**: `EventCollectionCreated`, `EventBatchAdded`, `EventBatchRemoved`, `EventQualityScoreSubmitted`, `EventChallengeCreated`, `EventChallengeResolved`, `EventCuratorSlashed`, `EventCuratorRewardClaimed`, `EventCollectionClosed`
- **Queries**: `QueryCollection`, `QueryCollectionsByBatch`, `QueryCollectionsByCurator`, `QueryQualityScore`, `QueryQualityScoreHistory`, `QueryCuratorRewards`, `QueryFeaturedBatches`
- **Dependencies**: M010 (reputation scores for quality inputs), M013 (fee routing for trade fees), AGENT-003 (quality scoring, price monitoring), x/ecocredit (batch/class/project data), KOI MCP (methodology analysis, cross-referencing)

---

## Summary

| Mechanism | Type | Complexity | Priority | Dependencies |
|-----------|------|------------|----------|--------------|
| M001-ENH | Enhancement | Medium | High | x/ecocredit, governance |
| M008 | New | High | High | x/data, DAO DAO |
| M009 | New | High | Medium | CosmWasm, M008 (Arbiter DAO), M010 (reputation) |
| M010 | New | Medium | High | x/staking, off-chain |
| M011 | Enhancement | Medium | Medium | x/ecocredit/marketplace, M010, M013, AGENT-003 |
