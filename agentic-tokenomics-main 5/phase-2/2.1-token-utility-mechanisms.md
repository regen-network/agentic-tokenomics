# Phase 2.1: Token Utility Mechanism Specifications

## Overview

This document contains protocol-level specifications for 5 token utility mechanisms (2 enhancements + 3 new), each ready for Phase 3 implementation.

---

## PROTOCOL SPECIFICATION: M001-ENH

### Credit Class Approval Voting Enhancement

#### Purpose
Enhance the existing credit class creator allowlist mechanism with tiered approval thresholds, automated pre-screening by agents, and expedited paths for low-risk proposals.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Proposer | Credit class creator seeking allowlist | Deposit: 1,000 REGEN |
| Validators | Block producers | Staked REGEN |
| Delegators | Token holders | Delegated REGEN |
| Registry Agent | Autonomous pre-screener | Service bond: 10,000 REGEN |

#### Token Flows
```
┌─────────────┐     deposit      ┌──────────────┐
│  Proposer   │ ────(1000)────→  │ Escrow Pool  │
└─────────────┘                  └──────────────┘
                                        │
       ┌────────────────────────────────┼────────────────────────────────┐
       │ APPROVED                       │ REJECTED                       │ EXPIRED
       ▼                                ▼                                ▼
┌──────────────┐              ┌──────────────┐              ┌──────────────┐
│  Proposer    │              │ Community    │              │  Proposer    │
│  (refund)    │              │ Pool (slash) │              │  (refund-fee)│
└──────────────┘              └──────────────┘              └──────────────┘
```

#### State Transitions
```
States: {DRAFT, AGENT_REVIEW, VOTING, APPROVED, REJECTED, EXPIRED}

DRAFT → AGENT_REVIEW
  trigger: proposer.submit(deposit=1000)
  guard: proposer.balance >= 1000
  action: escrow.lock(1000)

AGENT_REVIEW → VOTING
  trigger: agent.score >= 0.7 OR timeout(24h)
  guard: none
  action: governance.create_proposal()

AGENT_REVIEW → REJECTED
  trigger: agent.score < 0.3 AND agent.confidence > 0.9
  guard: human_override_window_expired(6h)
  action: escrow.slash(50%), escrow.refund(50%)

VOTING → APPROVED
  trigger: tally.yes_ratio > 0.5 AND quorum_met
  guard: voting_period_complete
  action: allowlist.add(proposer), escrow.refund(1000)

VOTING → REJECTED
  trigger: tally.yes_ratio <= 0.5 OR veto > 0.334
  guard: voting_period_complete
  action: escrow.slash(200), escrow.refund(800)
```

#### Security Invariants
1. **Deposit Conservation**: `sum(deposits) = sum(refunds) + sum(slashes) + escrow.balance`
2. **Agent Authority Bound**: Agent can only recommend; cannot directly approve/reject without human override window
3. **Governance Supremacy**: Human vote always overrides agent recommendation
4. **Slash Cap**: Maximum slash = 50% of deposit per proposal

#### Automation Logic
```yaml
agent_pre_screening:
  inputs:
    - methodology_document: IRI
    - credit_type: string
    - admin_address: bech32
  checks:
    - methodology_completeness: [additionality, baseline, MRV, permanence]
    - credit_type_validity: must exist in allowed_credit_types
    - admin_reputation: historical proposal success rate
    - duplicate_detection: cosine_similarity < 0.85 vs existing classes
  scoring:
    weight_methodology: 0.4
    weight_reputation: 0.3
    weight_novelty: 0.2
    weight_completeness: 0.1
  output:
    score: float[0,1]
    confidence: float[0,1]
    recommendation: APPROVE | REJECT | MANUAL_REVIEW
    rationale: string
```

#### Implementation Notes
- **Module**: Extend `x/ecocredit` with `MsgProposeClassCreator`
- **Storage**: New `ClassCreatorProposal` object with agent scores
- **Events**: `EventClassCreatorProposed`, `EventAgentScoreSubmitted`
- **Migration**: Backward compatible; existing allowlist preserved
- **Dependencies**: KOI MCP for methodology analysis, Ledger MCP for state queries

---

## PROTOCOL SPECIFICATION: M008

### Data Attestation Bonding

#### Purpose
Create economic incentives for high-quality ecological data attestations by requiring attesters to bond REGEN tokens that can be slashed for false or misleading claims.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Attester | Entity making ecological claims | Bond: varies by claim type |
| Challenger | Entity disputing attestation | Challenge deposit: 10% of bond |
| Arbiter DAO | Resolution body (subDAO) | Staked in arbiter pool |
| Beneficiary | Project receiving attestation | None |

#### Token Flows
```
┌─────────────┐     bond         ┌──────────────┐
│  Attester   │ ────(B)────────→ │ Attestation  │
└─────────────┘                  │ Bond Pool    │
                                 └──────────────┘
                                        │
       ┌────────────────────────────────┼────────────────────────────────┐
       │ UNCHALLENGED (lock_period)     │ CHALLENGED                     │
       ▼                                ▼
┌──────────────┐              ┌──────────────┐
│  Attester    │              │ Arbiter DAO  │
│  (refund+    │              │ Resolution   │
│   yield)     │              └──────┬───────┘
└──────────────┘                     │
                    ┌────────────────┼────────────────┐
                    │ ATTESTER WINS  │ CHALLENGER WINS│
                    ▼                ▼
              ┌──────────────┐ ┌──────────────┐
              │ Attester:    │ │ Challenger:  │
              │ bond+chal_dep│ │ bond+arb_fee │
              └──────────────┘ │ Arbiter: fee │
                               │ CommunityPool│
                               │ : remainder  │
                               └──────────────┘
```

#### State Transitions
```
States: {BONDED, ACTIVE, CHALLENGED, RESOLVED_VALID, RESOLVED_INVALID, RELEASED}

Initial → BONDED
  trigger: attester.bond(amount, attestation_iri)
  guard: amount >= min_bond[attestation_type]
  action: bond_pool.lock(amount), attestation.create()

BONDED → ACTIVE
  trigger: activation_delay_passed(48h)
  guard: no_challenge_submitted
  action: attestation.activate()

ACTIVE → CHALLENGED
  trigger: challenger.submit_challenge(evidence_iri, deposit)
  guard: deposit >= bond * 0.1, within_challenge_window
  action: challenge_pool.lock(deposit), attestation.pause()

CHALLENGED → RESOLVED_VALID
  trigger: arbiter_dao.vote(VALID)
  guard: quorum_met, voting_complete
  action: attester.receive(bond + challenge_deposit - arbiter_fee)

CHALLENGED → RESOLVED_INVALID
  trigger: arbiter_dao.vote(INVALID)
  guard: quorum_met, voting_complete
  action: challenger.receive(bond * 0.5 + deposit - arbiter_fee),
          community_pool.receive(bond * 0.5)

ACTIVE → RELEASED (after lock_period)
  trigger: lock_period_expired AND no_active_challenge
  action: attester.receive(bond + yield)
```

#### Bond Schedule by Attestation Type
| Attestation Type | Min Bond (REGEN) | Lock Period | Challenge Window |
|------------------|------------------|-------------|------------------|
| Project Boundary | 500 | 90 days | 60 days |
| Baseline Measurement | 1,000 | 180 days | 120 days |
| Credit Issuance Claim | 2,000 | 365 days | 300 days |
| Methodology Validation | 5,000 | 730 days | 600 days |

#### Security Invariants
1. **Bond Coverage**: `attestation.value_at_risk <= bond * coverage_ratio`
2. **Challenge Skin-in-Game**: Challengers must deposit to prevent spam
3. **Arbiter Neutrality**: Arbiters cannot be attester/challenger/beneficiary
4. **Slash Distribution**: Slashed bonds split between challenger (50%) and community pool (50%)

#### Implementation Notes
- **Module**: New `x/attestation` module or extend `x/data`
- **Storage**: `Attestation`, `Bond`, `Challenge`, `Resolution` objects
- **CosmWasm**: Arbiter DAO as DAO DAO subDAO contract
- **Dependencies**: IRI resolution for evidence, KOI for cross-referencing

---

## PROTOCOL SPECIFICATION: M009

### Service Provision Escrow

#### Purpose
Enable trustless engagement of ecosystem services (verification, monitoring, methodology development) with milestone-based payment release and dispute resolution.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Client | Service requester | Escrow amount |
| Provider | Service deliverer | Service bond: 10% of escrow |
| Arbiter | Dispute resolver | Staked in arbiter pool |

#### Token Flows
```
┌─────────────┐     escrow       ┌──────────────┐    service_bond   ┌──────────────┐
│   Client    │ ────(E)────────→ │   Escrow     │ ←────(0.1E)────── │   Provider   │
└─────────────┘                  │   Contract   │                   └──────────────┘
                                 └──────────────┘
                                        │
       ┌────────────────────────────────┼────────────────────────────────┐
       │ MILESTONE_APPROVED             │ DISPUTED                       │
       ▼                                ▼
┌──────────────┐              ┌──────────────┐
│  Provider    │              │ Arbiter      │
│  (milestone  │              │ Resolution   │
│   payment)   │              └──────┬───────┘
└──────────────┘                     │
                    ┌────────────────┴────────────────┐
                    │ CLIENT WINS    │ PROVIDER WINS  │
                    ▼                ▼
              ┌──────────────┐ ┌──────────────┐
              │ Client:      │ │ Provider:    │
              │ escrow-fees  │ │ escrow+bond  │
              │ Provider:    │ │ Client: 0    │
              │ slashed bond │ └──────────────┘
              └──────────────┘
```

#### State Transitions
```
States: {PROPOSED, FUNDED, IN_PROGRESS, MILESTONE_REVIEW, COMPLETED, DISPUTED, CANCELLED}

Initial → PROPOSED
  trigger: client.propose_service(spec, milestones, escrow_amount)
  action: service_agreement.create()

PROPOSED → FUNDED
  trigger: provider.accept(service_bond) AND client.fund(escrow_amount)
  guard: provider.reputation >= min_reputation
  action: escrow.lock(escrow_amount + service_bond)

FUNDED → IN_PROGRESS
  trigger: start_date_reached OR both_parties_confirm
  action: milestone[0].activate()

IN_PROGRESS → MILESTONE_REVIEW
  trigger: provider.submit_deliverable(milestone_id, evidence_iri)
  action: milestone.set_pending_review()

MILESTONE_REVIEW → IN_PROGRESS
  trigger: client.approve_milestone(milestone_id)
  action: provider.receive(milestone.payment), next_milestone.activate()

MILESTONE_REVIEW → DISPUTED
  trigger: client.dispute(milestone_id, reason) OR timeout(review_period)
  action: dispute.create(), arbiter.assign()

IN_PROGRESS → COMPLETED
  trigger: all_milestones_approved
  action: provider.receive(service_bond), agreement.close()
```

#### Standard Service Types
| Service Type | Typical Escrow | Milestones | Review Period |
|--------------|----------------|------------|---------------|
| Project Verification | 2,000-10,000 REGEN | 3-5 | 14 days |
| Methodology Development | 10,000-50,000 REGEN | 5-10 | 21 days |
| MRV Setup | 5,000-20,000 REGEN | 4-6 | 14 days |
| Credit Issuance Support | 1,000-5,000 REGEN | 2-3 | 7 days |

#### Implementation Notes
- **Module**: New `x/service` module or CosmWasm contract
- **Storage**: `ServiceAgreement`, `Milestone`, `Dispute` objects
- **Integration**: Link to `x/ecocredit` for credit-related services

---

## PROTOCOL SPECIFICATION: M010

### Reputation/Legitimacy Signaling

#### Purpose
Create a non-transferable reputation system where stakeholders can signal endorsement of entities through stake-weighted attestations, building verifiable track records.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Subject | Entity receiving reputation signals | None |
| Signaler | Entity providing endorsement | Staked REGEN (not locked) |
| Aggregator | System computing reputation scores | None |

#### Token Flows
```
Note: No token transfers occur. Reputation is derived from:
1. Staked REGEN balance of signalers
2. Signaler's own reputation score
3. Historical accuracy of signaler's endorsements

Weight = S * R * decay(age) * category_relevance
```

#### Reputation Calculation
```
subject_reputation[category] =
  sum(
    for each signal in signals[subject][category]:
      signal.weight * signaler.reputation * time_decay(signal.age)
  ) / normalization_factor

time_decay(age) = e^(-age / half_life)
  where half_life = 365 days

stake_factor(s) = log(1 + s / 1000) / log(1 + max_stake / 1000)
```

#### Reputation Categories
| Category | Min Stake | Half-Life | Use Cases |
|----------|-----------|-----------|-----------|
| Credit Class Quality | 1,000 REGEN | 2 years | Class approval, buyer confidence |
| Project Legitimacy | 500 REGEN | 1 year | Project verification priority |
| Verifier Competence | 2,000 REGEN | 3 years | Service provider selection |
| Methodology Rigor | 5,000 REGEN | 5 years | Methodology approval |

#### Security Invariants
1. **Non-Transferability**: Reputation scores cannot be bought/sold
2. **Stake Requirement**: Signals require active stake (not historical)
3. **Sybil Resistance**: Weight = f(stake, reputation), not count
4. **Accountability**: Signal history is permanent and public

#### Implementation Notes
- **Module**: New `x/reputation` module
- **Storage**: `Signal`, `ReputationScore`, `Challenge` objects
- **Computation**: Off-chain aggregation with on-chain anchoring

---

## PROTOCOL SPECIFICATION: M011

### Marketplace Curation & Quality Signals

#### Purpose
Enhance the existing marketplace with quality signals, curated collections, and price discovery mechanisms that surface high-integrity credits.

#### Participants
| Role | Description | Token Requirement |
|------|-------------|-------------------|
| Seller | Credit holder listing for sale | Listing fee: 10 REGEN |
| Buyer | Credit purchaser | Purchase amount |
| Curator | Collection creator/maintainer | Curation bond: 1,000 REGEN |
| Market Agent | Automated quality assessor | Service bond: 5,000 REGEN |

#### Curation Collections
```yaml
Collection:
  curator: address
  bond: amount
  criteria: CurationCriteria
  members: []BatchDenom
  fee_share: percentage

CurationCriteria:
  min_project_reputation: float
  min_class_reputation: float
  allowed_credit_types: []string
  geographic_scope: []region
  vintage_range: {min, max}
```

#### Quality Scoring Algorithm
```
quality_score = weighted_sum(
  project_reputation: 0.25,
  class_reputation: 0.20,
  vintage_freshness: 0.15,
  verification_recency: 0.15,
  seller_reputation: 0.10,
  price_fairness: 0.10,
  additionality_confidence: 0.05
)
```

#### Implementation Notes
- **Module**: Extend `x/ecocredit/marketplace`
- **Storage**: `Collection`, `QualityScore`, `CurationBond` objects

---

## Summary

| Mechanism | Type | Complexity | Priority | Dependencies |
|-----------|------|------------|----------|--------------|
| M001-ENH | Enhancement | Medium | High | x/ecocredit, governance |
| M008 | New | High | High | x/data, DAO DAO |
| M009 | New | High | Medium | CosmWasm, x/escrow |
| M010 | New | Medium | High | x/staking, off-chain |
| M011 | Enhancement | Medium | Medium | x/ecocredit/marketplace |
