# Phase 3.3: Integration Testing Plan

## Overview

This document specifies testing strategies, test cases, and validation procedures for the agentic tokenomics system.

---

## Testing Strategy

### Test Pyramid

```
                    ┌─────────┐
                    │   E2E   │  ← 10% of tests
                    │  Tests  │     Full system validation
                   ─┴─────────┴─
                  ┌─────────────┐
                  │ Integration │  ← 30% of tests
                  │   Tests     │     Component interactions
                 ─┴─────────────┴─
                ┌─────────────────┐
                │    Unit Tests   │  ← 60% of tests
                │                 │     Individual functions
               ─┴─────────────────┴─
```

### Test Categories

| Category | Scope | Tools | Coverage Target |
|----------|-------|-------|-----------------|
| Unit | Functions, modules | Jest, Go test | 80% |
| Integration | Component interactions | Jest, Testcontainers | 70% |
| Contract | Smart contracts | CosmWasm test framework | 90% |
| E2E | Full workflows | Playwright, Custom harness | Critical paths |
| Load | Performance | k6, Locust | SLO validation |
| Security | Vulnerability scanning | Slither, Semgrep | All contracts |

---

## Unit Test Specifications

### Smart Contract Unit Tests

```rust
// contracts/attestation-bond/src/tests.rs

#[cfg(test)]
mod tests {
    use super::*;
    use cosmwasm_std::testing::{mock_dependencies, mock_env, mock_info};
    use cosmwasm_std::{coins, Addr, Timestamp};

    #[test]
    fn test_instantiate() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        let info = mock_info("creator", &coins(1000, "uregen"));

        let msg = InstantiateMsg {
            admin: "admin".to_string(),
            arbiter_dao: "dao".to_string(),
            min_bond: Uint128::new(100_000_000),
            lock_period: 86400 * 30, // 30 days
            challenge_window: 86400 * 7, // 7 days
        };

        let res = instantiate(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(0, res.messages.len());

        // Verify config stored
        let config = CONFIG.load(&deps.storage).unwrap();
        assert_eq!(config.admin, Addr::unchecked("admin"));
        assert_eq!(config.min_bond, Uint128::new(100_000_000));
    }

    #[test]
    fn test_create_attestation_bond_success() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        setup_contract(deps.as_mut());

        let info = mock_info("attester", &coins(100_000_000, "uregen"));
        let msg = ExecuteMsg::CreateBond {
            attestation_type: "project_verification".to_string(),
            attestation_iri: "regen:13abc...".to_string(),
            beneficiary: None,
        };

        let res = execute(deps.as_mut(), env.clone(), info, msg).unwrap();

        assert_eq!(res.attributes.len(), 4);
        assert_eq!(res.attributes[0].value, "create_bond");

        // Verify attestation stored
        let attestation = ATTESTATIONS.load(&deps.storage, 1u64).unwrap();
        assert_eq!(attestation.attester, Addr::unchecked("attester"));
        assert_eq!(attestation.status, BondStatus::Active);
    }

    #[test]
    fn test_create_attestation_bond_insufficient_funds() {
        let mut deps = mock_dependencies();
        let env = mock_env();
        setup_contract(deps.as_mut());

        let info = mock_info("attester", &coins(50_000_000, "uregen")); // Below minimum
        let msg = ExecuteMsg::CreateBond {
            attestation_type: "project_verification".to_string(),
            attestation_iri: "regen:13abc...".to_string(),
            beneficiary: None,
        };

        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();
        assert!(matches!(err, ContractError::InsufficientBond { .. }));
    }

    #[test]
    fn test_challenge_attestation() {
        let mut deps = mock_dependencies();
        let mut env = mock_env();
        setup_contract(deps.as_mut());
        create_test_attestation(deps.as_mut(), &env);

        // Advance time to within challenge window
        env.block.time = env.block.time.plus_seconds(86400); // 1 day later

        let info = mock_info("challenger", &coins(50_000_000, "uregen"));
        let msg = ExecuteMsg::Challenge {
            attestation_id: 1,
            evidence_iri: "regen:13evidence...".to_string(),
        };

        let res = execute(deps.as_mut(), env, info, msg).unwrap();
        assert_eq!(res.attributes[0].value, "challenge");

        // Verify status changed
        let attestation = ATTESTATIONS.load(&deps.storage, 1u64).unwrap();
        assert_eq!(attestation.status, BondStatus::Challenged);
    }

    #[test]
    fn test_challenge_after_window_fails() {
        let mut deps = mock_dependencies();
        let mut env = mock_env();
        setup_contract(deps.as_mut());
        create_test_attestation(deps.as_mut(), &env);

        // Advance time past challenge window
        env.block.time = env.block.time.plus_seconds(86400 * 10); // 10 days later

        let info = mock_info("challenger", &coins(50_000_000, "uregen"));
        let msg = ExecuteMsg::Challenge {
            attestation_id: 1,
            evidence_iri: "regen:13evidence...".to_string(),
        };

        let err = execute(deps.as_mut(), env, info, msg).unwrap_err();
        assert!(matches!(err, ContractError::ChallengeWindowClosed {}));
    }

    #[test]
    fn test_release_bond_after_lock_period() {
        let mut deps = mock_dependencies();
        let mut env = mock_env();
        setup_contract(deps.as_mut());
        create_test_attestation(deps.as_mut(), &env);

        // Advance time past lock period
        env.block.time = env.block.time.plus_seconds(86400 * 35); // 35 days later

        let info = mock_info("attester", &[]);
        let msg = ExecuteMsg::ReleaseBond { attestation_id: 1 };

        let res = execute(deps.as_mut(), env, info, msg).unwrap();

        // Should have BankMsg::Send
        assert_eq!(res.messages.len(), 1);

        // Verify status updated
        let attestation = ATTESTATIONS.load(&deps.storage, 1u64).unwrap();
        assert_eq!(attestation.status, BondStatus::Released);
    }

    fn setup_contract(deps: DepsMut) {
        let env = mock_env();
        let info = mock_info("creator", &[]);
        let msg = InstantiateMsg {
            admin: "admin".to_string(),
            arbiter_dao: "dao".to_string(),
            min_bond: Uint128::new(100_000_000),
            lock_period: 86400 * 30,
            challenge_window: 86400 * 7,
        };
        instantiate(deps, env, info, msg).unwrap();
    }

    fn create_test_attestation(deps: DepsMut, env: &Env) {
        let info = mock_info("attester", &coins(100_000_000, "uregen"));
        let msg = ExecuteMsg::CreateBond {
            attestation_type: "project_verification".to_string(),
            attestation_iri: "regen:13abc...".to_string(),
            beneficiary: None,
        };
        execute(deps, env.clone(), info, msg).unwrap();
    }
}
```

### Agent Action Unit Tests

```typescript
// packages/plugin-registry-tools/src/actions/__tests__/analyze-methodology.test.ts

import { describe, it, expect, beforeEach, vi } from "vitest";
import { analyzeMethodologyAction } from "../analyze-methodology";
import { createMockRuntime, createMockMemory } from "@elizaos/core/testing";

describe("analyzeMethodologyAction", () => {
  let mockRuntime: any;
  let mockKoiClient: any;

  beforeEach(() => {
    mockKoiClient = {
      search: vi.fn(),
    };

    mockRuntime = createMockRuntime({
      services: {
        "koi-mcp": mockKoiClient,
      },
    });
  });

  describe("validate", () => {
    it("should return true for methodology analysis requests", async () => {
      const message = createMockMemory({
        text: "analyze methodology VM0042",
      });

      const result = await analyzeMethodologyAction.validate(mockRuntime, message);
      expect(result).toBe(true);
    });

    it("should return false for unrelated requests", async () => {
      const message = createMockMemory({
        text: "what is the weather today",
      });

      const result = await analyzeMethodologyAction.validate(mockRuntime, message);
      expect(result).toBe(false);
    });
  });

  describe("handler", () => {
    it("should analyze methodology and return completeness score", async () => {
      mockKoiClient.search.mockResolvedValue({
        results: [
          { content: "baseline scenario establishment protocol" },
          { content: "monitoring and measurement requirements" },
          { content: "quantification methodology for carbon" },
          { content: "verification and audit procedures" },
          { content: "permanence buffer pool calculation" },
        ],
      });

      const message = createMockMemory({
        text: "analyze methodology VM0042",
      });

      let callbackResult: any;
      const callback = (result: any) => {
        callbackResult = result;
      };

      await analyzeMethodologyAction.handler(
        mockRuntime,
        message,
        {},
        {},
        callback
      );

      expect(callbackResult.text).toContain("VM0042");
      expect(callbackResult.text).toContain("Completeness Score");
      expect(callbackResult.text).toContain("Found");
    });

    it("should identify missing components", async () => {
      mockKoiClient.search.mockResolvedValue({
        results: [
          { content: "baseline establishment only" },
        ],
      });

      const message = createMockMemory({
        text: "review methodology ACR001",
      });

      let callbackResult: any;
      const callback = (result: any) => {
        callbackResult = result;
      };

      await analyzeMethodologyAction.handler(
        mockRuntime,
        message,
        {},
        {},
        callback
      );

      expect(callbackResult.text).toContain("Missing");
    });

    it("should handle no methodology found", async () => {
      const message = createMockMemory({
        text: "analyze methodology",
      });

      let callbackResult: any;
      const callback = (result: any) => {
        callbackResult = result;
      };

      await analyzeMethodologyAction.handler(
        mockRuntime,
        message,
        {},
        {},
        callback
      );

      expect(callbackResult.text).toContain("Could not identify");
    });
  });
});
```

---

## Integration Test Specifications

### MCP Integration Tests

```typescript
// tests/integration/mcp-integration.test.ts

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { GenericContainer, StartedTestContainer } from "testcontainers";
import { LedgerMCPClient } from "@regen/plugin-ledger-mcp";
import { KOIMCPClient } from "@regen/plugin-koi-mcp";

describe("MCP Integration Tests", () => {
  let ledgerMcpContainer: StartedTestContainer;
  let koiMcpContainer: StartedTestContainer;
  let ledgerClient: LedgerMCPClient;
  let koiClient: KOIMCPClient;

  beforeAll(async () => {
    // Start test containers
    ledgerMcpContainer = await new GenericContainer("regen/ledger-mcp:test")
      .withExposedPorts(3001)
      .withEnvironment({
        REGEN_NODE_URL: "https://regen-testnet-rpc.polkachu.com",
        REGEN_CHAIN_ID: "regen-redwood-1",
      })
      .start();

    koiMcpContainer = await new GenericContainer("regen/koi-mcp:test")
      .withExposedPorts(3002)
      .start();

    ledgerClient = new LedgerMCPClient({
      baseUrl: `http://localhost:${ledgerMcpContainer.getMappedPort(3001)}`,
      apiKey: "test-key",
    });

    koiClient = new KOIMCPClient({
      baseUrl: `http://localhost:${koiMcpContainer.getMappedPort(3002)}`,
      apiKey: "test-key",
    });
  }, 120000);

  afterAll(async () => {
    await ledgerMcpContainer?.stop();
    await koiMcpContainer?.stop();
  });

  describe("Ledger MCP", () => {
    it("should list credit classes", async () => {
      const result = await ledgerClient.listClasses({ limit: 10 });

      expect(result.classes).toBeDefined();
      expect(Array.isArray(result.classes)).toBe(true);
    });

    it("should get governance proposals", async () => {
      const result = await ledgerClient.call("list_governance_proposals", {
        limit: 5,
      });

      expect(result.proposals).toBeDefined();
      expect(Array.isArray(result.proposals)).toBe(true);
    });

    it("should handle invalid proposal ID gracefully", async () => {
      const result = await ledgerClient.getProposal(999999);

      expect(result).toBeNull();
    });
  });

  describe("KOI MCP", () => {
    it("should search knowledge base", async () => {
      const result = await koiClient.search({
        query: "carbon credits",
        limit: 5,
      });

      expect(result.results).toBeDefined();
      expect(Array.isArray(result.results)).toBe(true);
    });

    it("should resolve entities", async () => {
      const result = await koiClient.resolveEntity("regen network");

      expect(result.matches).toBeDefined();
    });

    it("should execute SPARQL queries", async () => {
      const result = await koiClient.sparqlQuery(
        "SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 10",
        10
      );

      expect(result.results).toBeDefined();
    });
  });

  describe("Cross-MCP Integration", () => {
    it("should correlate on-chain class with KOI documentation", async () => {
      // Get a credit class from ledger
      const classes = await ledgerClient.listClasses({ limit: 1 });
      expect(classes.classes.length).toBeGreaterThan(0);

      const creditClass = classes.classes[0];

      // Search for related documentation in KOI
      const docs = await koiClient.search({
        query: creditClass.id,
        limit: 5,
      });

      // Should find some related documentation
      expect(docs.results).toBeDefined();
    });
  });
});
```

### Agent Workflow Integration Tests

```typescript
// tests/integration/workflows.test.ts

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { AgentRuntime } from "@elizaos/core";
import { registryReviewerCharacter } from "../../characters/registry-reviewer";
import { OODAExecutor } from "../../packages/core/src/workflows/ooda-executor";
import { Pool } from "pg";

describe("Agent Workflow Integration", () => {
  let runtime: AgentRuntime;
  let executor: OODAExecutor;
  let dbPool: Pool;

  beforeAll(async () => {
    dbPool = new Pool({
      connectionString: process.env.TEST_DATABASE_URL,
    });

    // Initialize agent runtime with test configuration
    runtime = new AgentRuntime({
      character: registryReviewerCharacter,
      database: dbPool,
      mcpClients: {
        ledger: createTestLedgerClient(),
        koi: createTestKoiClient(),
      },
    });

    executor = new OODAExecutor(runtime);
  });

  afterAll(async () => {
    await dbPool.end();
  });

  describe("WF-RR-01: Credit Class Creator Pre-Screening", () => {
    it("should complete observation phase", async () => {
      const workflow = {
        id: "WF-RR-01",
        observe: [
          { type: "ledger_query", tool: "get_account", params: { address: "regen1test..." } },
          { type: "koi_search", params: { query: "methodology VM0042", limit: 10 } },
        ],
        orient: [
          { type: "analyze", prompt: "Analyze applicant history" },
        ],
        decide: {
          type: "recommend",
          escalationThreshold: 0.7,
        },
        act: [
          { type: "create_koi_object", condition: "$decision.action !== 'ESCALATE'" },
        ],
      };

      const trigger = {
        id: "test-trigger",
        agentId: runtime.agentId,
        content: {
          text: "New credit class creator application",
          metadata: {
            applicant: "regen1test...",
            methodology: "VM0042",
          },
        },
      };

      const execution = await executor.execute(workflow, trigger);

      expect(execution.status).toMatch(/completed|escalated/);
      expect(execution.observations.length).toBe(2);
      expect(execution.decision).toBeDefined();
    });

    it("should escalate when confidence is low", async () => {
      const workflow = {
        id: "WF-RR-01",
        observe: [
          { type: "ledger_query", tool: "get_account", params: { address: "regen1unknown..." } },
        ],
        orient: [],
        decide: {
          type: "recommend",
          escalationThreshold: 0.9, // High threshold
        },
        act: [],
      };

      const trigger = {
        id: "test-trigger",
        agentId: runtime.agentId,
        content: { text: "Unknown applicant" },
      };

      const execution = await executor.execute(workflow, trigger);

      expect(execution.status).toBe("escalated");
    });
  });

  describe("WF-GA-01: Proposal Analysis", () => {
    it("should generate proposal analysis", async () => {
      const workflow = {
        id: "WF-GA-01",
        observe: [
          { type: "ledger_query", tool: "get_governance_proposal", params: { proposal_id: 1 } },
          { type: "ledger_query", tool: "list_governance_votes", params: { proposal_id: 1 } },
          { type: "koi_search", params: { query: "governance proposal history", limit: 5 } },
        ],
        orient: [
          { type: "analyze", prompt: "Analyze proposal impact" },
        ],
        decide: {
          type: "publish",
          escalationThreshold: 0.5,
        },
        act: [
          { type: "post_message", channel: "governance" },
        ],
      };

      const trigger = {
        id: "proposal-trigger",
        agentId: runtime.agentId,
        content: {
          text: "Proposal #1 submitted",
          metadata: { proposal_id: 1 },
        },
      };

      const execution = await executor.execute(workflow, trigger);

      expect(execution.status).toBe("completed");
      expect(execution.decision.action).toBeDefined();
    });
  });
});
```

---

## End-to-End Test Specifications

### Full System E2E Tests

```typescript
// tests/e2e/full-system.test.ts

import { describe, it, expect, beforeAll, afterAll } from "vitest";
import { chromium, Browser, Page } from "playwright";

describe("Full System E2E Tests", () => {
  let browser: Browser;
  let page: Page;

  beforeAll(async () => {
    browser = await chromium.launch();
    page = await browser.newPage();
  });

  afterAll(async () => {
    await browser.close();
  });

  describe("Governance Analyst Flow", () => {
    it("should display proposal analysis on Discord command", async () => {
      // This would test the full flow from Discord command to response
      // Using a test Discord server or mock

      // 1. Send command to agent
      // 2. Wait for response
      // 3. Verify response contains expected elements

      // Placeholder for actual Discord bot testing
      expect(true).toBe(true);
    });

    it("should publish voting update to Twitter", async () => {
      // Test full flow of voting update publication
      // Using Twitter API mock or sandbox

      expect(true).toBe(true);
    });
  });

  describe("Registry Reviewer Flow", () => {
    it("should complete credit class pre-screening workflow", async () => {
      // Full workflow test:
      // 1. Submit application
      // 2. Trigger agent processing
      // 3. Verify recommendation generated
      // 4. Verify KOI object created
      // 5. Verify forum post created (if applicable)

      expect(true).toBe(true);
    });
  });

  describe("Market Monitor Flow", () => {
    it("should detect and alert on price anomaly", async () => {
      // Test anomaly detection:
      // 1. Inject test market data with anomaly
      // 2. Trigger market scan
      // 3. Verify alert generated
      // 4. Verify alert delivered to correct channels

      expect(true).toBe(true);
    });
  });
});
```

### Contract E2E Tests

```rust
// contracts/integration-tests/src/tests.rs

use cosmwasm_std::{Addr, Coin, Uint128};
use cw_multi_test::{App, AppBuilder, ContractWrapper, Executor};

fn mock_app() -> App {
    AppBuilder::new().build(|router, _, storage| {
        router
            .bank
            .init_balance(
                storage,
                &Addr::unchecked("attester"),
                vec![Coin::new(1_000_000_000u128, "uregen")],
            )
            .unwrap();
    })
}

#[test]
fn test_full_attestation_lifecycle() {
    let mut app = mock_app();

    // Deploy attestation bond contract
    let attestation_code = ContractWrapper::new(
        attestation_bond::contract::execute,
        attestation_bond::contract::instantiate,
        attestation_bond::contract::query,
    );
    let attestation_code_id = app.store_code(Box::new(attestation_code));

    let attestation_addr = app
        .instantiate_contract(
            attestation_code_id,
            Addr::unchecked("admin"),
            &attestation_bond::msg::InstantiateMsg {
                admin: "admin".to_string(),
                arbiter_dao: "dao".to_string(),
                min_bond: Uint128::new(100_000_000),
                lock_period: 86400 * 30,
                challenge_window: 86400 * 7,
            },
            &[],
            "attestation-bond",
            None,
        )
        .unwrap();

    // 1. Create attestation bond
    let create_msg = attestation_bond::msg::ExecuteMsg::CreateBond {
        attestation_type: "project_verification".to_string(),
        attestation_iri: "regen:13abc...".to_string(),
        beneficiary: None,
    };

    app.execute_contract(
        Addr::unchecked("attester"),
        attestation_addr.clone(),
        &create_msg,
        &[Coin::new(100_000_000u128, "uregen")],
    )
    .unwrap();

    // 2. Verify attestation created
    let query_msg = attestation_bond::msg::QueryMsg::Attestation { id: 1 };
    let attestation: attestation_bond::state::Attestation = app
        .wrap()
        .query_wasm_smart(attestation_addr.clone(), &query_msg)
        .unwrap();

    assert_eq!(attestation.status, attestation_bond::state::BondStatus::Active);

    // 3. Advance time past lock period
    app.update_block(|block| {
        block.time = block.time.plus_seconds(86400 * 35);
    });

    // 4. Release bond
    let release_msg = attestation_bond::msg::ExecuteMsg::ReleaseBond { attestation_id: 1 };

    app.execute_contract(
        Addr::unchecked("attester"),
        attestation_addr.clone(),
        &release_msg,
        &[],
    )
    .unwrap();

    // 5. Verify bond released
    let attestation: attestation_bond::state::Attestation = app
        .wrap()
        .query_wasm_smart(attestation_addr, &query_msg)
        .unwrap();

    assert_eq!(attestation.status, attestation_bond::state::BondStatus::Released);
}

#[test]
fn test_challenge_and_arbitration() {
    let mut app = mock_app();

    // ... setup contracts ...

    // 1. Create attestation
    // 2. Challenge within window
    // 3. Arbiter DAO resolves
    // 4. Verify correct fund distribution
}
```

---

## Load Test Specifications

### Agent Load Tests

```javascript
// tests/load/agent-load.js (k6)

import http from "k6/http";
import { check, sleep } from "k6";
import { Rate, Trend } from "k6/metrics";

const errorRate = new Rate("errors");
const responseTime = new Trend("response_time");

export const options = {
  stages: [
    { duration: "1m", target: 10 },   // Ramp up
    { duration: "5m", target: 50 },   // Sustain
    { duration: "1m", target: 100 },  // Peak
    { duration: "1m", target: 0 },    // Ramp down
  ],
  thresholds: {
    http_req_duration: ["p(95)<2000"], // 95% under 2s
    errors: ["rate<0.1"],              // Error rate under 10%
  },
};

const BASE_URL = __ENV.AGENT_URL || "http://localhost:8080";

export default function () {
  // Simulate governance analysis request
  const governancePayload = JSON.stringify({
    message: "Analyze proposal 62",
    agentId: "governance-analyst",
  });

  const governanceRes = http.post(`${BASE_URL}/api/agent/message`, governancePayload, {
    headers: { "Content-Type": "application/json" },
  });

  check(governanceRes, {
    "governance status 200": (r) => r.status === 200,
    "governance has response": (r) => r.json().response !== undefined,
  });

  errorRate.add(governanceRes.status !== 200);
  responseTime.add(governanceRes.timings.duration);

  sleep(1);

  // Simulate market health check
  const marketPayload = JSON.stringify({
    message: "Market health check",
    agentId: "market-monitor",
  });

  const marketRes = http.post(`${BASE_URL}/api/agent/message`, marketPayload, {
    headers: { "Content-Type": "application/json" },
  });

  check(marketRes, {
    "market status 200": (r) => r.status === 200,
  });

  errorRate.add(marketRes.status !== 200);
  responseTime.add(marketRes.timings.duration);

  sleep(1);
}

export function handleSummary(data) {
  return {
    "load-test-summary.json": JSON.stringify(data, null, 2),
  };
}
```

### MCP Load Tests

```javascript
// tests/load/mcp-load.js

import http from "k6/http";
import { check, group } from "k6";

export const options = {
  scenarios: {
    ledger_queries: {
      executor: "constant-arrival-rate",
      rate: 50,              // 50 requests per second
      timeUnit: "1s",
      duration: "5m",
      preAllocatedVUs: 20,
    },
    koi_searches: {
      executor: "constant-arrival-rate",
      rate: 30,
      timeUnit: "1s",
      duration: "5m",
      preAllocatedVUs: 15,
    },
  },
  thresholds: {
    "http_req_duration{scenario:ledger_queries}": ["p(95)<500"],
    "http_req_duration{scenario:koi_searches}": ["p(95)<1000"],
  },
};

const LEDGER_MCP_URL = __ENV.LEDGER_MCP_URL || "http://localhost:3001";
const KOI_MCP_URL = __ENV.KOI_MCP_URL || "http://localhost:3002";

export default function () {
  group("Ledger MCP", () => {
    const res = http.post(
      `${LEDGER_MCP_URL}/mcp/tools/list_classes`,
      JSON.stringify({ limit: 10 }),
      { headers: { "Content-Type": "application/json" } }
    );

    check(res, {
      "ledger status ok": (r) => r.status === 200,
      "ledger response valid": (r) => {
        const body = r.json();
        return body.classes !== undefined;
      },
    });
  });

  group("KOI MCP", () => {
    const res = http.post(
      `${KOI_MCP_URL}/mcp/tools/search`,
      JSON.stringify({ query: "carbon credits", limit: 5 }),
      { headers: { "Content-Type": "application/json" } }
    );

    check(res, {
      "koi status ok": (r) => r.status === 200,
      "koi response valid": (r) => {
        const body = r.json();
        return body.results !== undefined;
      },
    });
  });
}
```

---

## Test Environment Configuration

### Docker Compose for Testing

```yaml
# docker-compose.test.yml
version: '3.8'

services:
  postgres-test:
    image: pgvector/pgvector:pg16
    environment:
      POSTGRES_PASSWORD: test
      POSTGRES_DB: agents_test
    ports:
      - "5433:5432"
    tmpfs:
      - /var/lib/postgresql/data

  redis-test:
    image: redis:7-alpine
    ports:
      - "6380:6379"

  ledger-mcp-test:
    image: regen/ledger-mcp:test
    environment:
      REGEN_NODE_URL: https://regen-testnet-rpc.polkachu.com
      REGEN_CHAIN_ID: regen-redwood-1
    ports:
      - "3101:3001"

  koi-mcp-test:
    image: regen/koi-mcp:test
    environment:
      JENA_ENDPOINT: http://jena-test:3030
      TEST_MODE: "true"
    ports:
      - "3102:3002"
```

### CI/CD Pipeline Configuration

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run unit tests
        run: npm run test:unit -- --coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3

  contract-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: wasm32-unknown-unknown

      - name: Run contract tests
        run: |
          cd contracts
          cargo test --all

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: pgvector/pgvector:pg16
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: agents_test
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Run integration tests
        run: npm run test:integration
        env:
          TEST_DATABASE_URL: postgresql://postgres:test@localhost:5432/agents_test

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests, contract-tests]
    steps:
      - uses: actions/checkout@v4

      - name: Start test environment
        run: docker-compose -f docker-compose.test.yml up -d

      - name: Wait for services
        run: sleep 30

      - name: Run E2E tests
        run: npm run test:e2e

      - name: Cleanup
        run: docker-compose -f docker-compose.test.yml down

  load-tests:
    runs-on: ubuntu-latest
    needs: [e2e-tests]
    if: github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Setup k6
        run: |
          sudo gpg -k
          sudo gpg --no-default-keyring --keyring /usr/share/keyrings/k6-archive-keyring.gpg --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
          echo "deb [signed-by=/usr/share/keyrings/k6-archive-keyring.gpg] https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
          sudo apt-get update
          sudo apt-get install k6

      - name: Run load tests
        run: k6 run tests/load/agent-load.js
```

---

## Summary

| Test Type | Framework | Target | Status |
|-----------|-----------|--------|--------|
| Contract Unit | CosmWasm test | 90% coverage | Specified |
| Agent Unit | Vitest | 80% coverage | Specified |
| MCP Integration | Testcontainers | All endpoints | Specified |
| Workflow Integration | Custom harness | Critical paths | Specified |
| E2E | Playwright + cw-multi-test | Full flows | Specified |
| Load | k6 | SLO validation | Specified |
| Security | Slither, Semgrep | All contracts | Phase 3.4 |
