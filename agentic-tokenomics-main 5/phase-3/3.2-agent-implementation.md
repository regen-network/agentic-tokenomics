# Phase 3.2: Agent Implementation Guide

## Overview

This guide provides implementation specifications for building autonomous agents using ElizaOS runtime, integrated with Regen Network's MCP infrastructure.

---

## ElizaOS Plugin Architecture

### @regen/plugin-ledger-mcp

```typescript
// packages/plugin-ledger-mcp/src/index.ts
import { Plugin, IAgentRuntime, Action, Provider, Evaluator } from "@elizaos/core";
import { LedgerMCPClient } from "./client";

export const ledgerMCPPlugin: Plugin = {
  name: "@regen/plugin-ledger-mcp",
  description: "Regen Ledger MCP integration for on-chain data access",

  actions: [
    queryClassesAction,
    queryProjectsAction,
    queryBatchesAction,
    queryProposalsAction,
    queryValidatorsAction,
    queryMarketAction,
  ],

  providers: [
    ledgerStateProvider,
    governanceStateProvider,
    marketStateProvider,
  ],

  evaluators: [
    chainHealthEvaluator,
    proposalStatusEvaluator,
  ],

  services: [
    LedgerMCPService,
  ],
};

// Client wrapper
export class LedgerMCPClient {
  private baseUrl: string;
  private apiKey: string;

  constructor(config: LedgerMCPConfig) {
    this.baseUrl = config.baseUrl || "http://localhost:3001";
    this.apiKey = config.apiKey;
  }

  async listClasses(params: { limit?: number; offset?: number }) {
    return this.call("list_classes", params);
  }

  async listProjects(params: { limit?: number; offset?: number }) {
    return this.call("list_projects", params);
  }

  async getProposal(proposalId: string | number) {
    return this.call("get_governance_proposal", { proposal_id: proposalId });
  }

  async listSellOrders(params: { limit?: number; page?: number }) {
    return this.call("list_sell_orders", params);
  }

  async getValidatorOutstandingRewards(validatorAddress: string) {
    return this.call("get_validator_outstanding_rewards", { validator_address: validatorAddress });
  }

  private async call(tool: string, params: Record<string, unknown>) {
    const response = await fetch(`${this.baseUrl}/mcp/tools/${tool}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify(params),
    });

    if (!response.ok) {
      throw new Error(`MCP call failed: ${response.statusText}`);
    }

    return response.json();
  }
}
```

### @regen/plugin-koi-mcp

```typescript
// packages/plugin-koi-mcp/src/index.ts
import { Plugin, IAgentRuntime } from "@elizaos/core";
import { KOIMCPClient } from "./client";

export const koiMCPPlugin: Plugin = {
  name: "@regen/plugin-koi-mcp",
  description: "Regen KOI MCP integration for knowledge graph access",

  actions: [
    searchKnowledgeAction,
    resolveEntityAction,
    queryCodeGraphAction,
    sparqlQueryAction,
  ],

  providers: [
    knowledgeContextProvider,
    entityNeighborhoodProvider,
  ],

  evaluators: [
    documentRelevanceEvaluator,
  ],

  services: [
    KOIMCPService,
  ],
};

export class KOIMCPClient {
  private baseUrl: string;
  private apiKey: string;

  constructor(config: KOIMCPConfig) {
    this.baseUrl = config.baseUrl || "http://localhost:3002";
    this.apiKey = config.apiKey;
  }

  async search(params: {
    query: string;
    intent?: "general" | "person_activity" | "technical_howto";
    limit?: number;
    source?: string;
  }) {
    return this.call("search", params);
  }

  async resolveEntity(label: string, typeHint?: string) {
    return this.call("resolve_entity", { label, type_hint: typeHint });
  }

  async queryCodeGraph(params: {
    query_type: string;
    entity_name?: string;
    repo_name?: string;
  }) {
    return this.call("query_code_graph", params);
  }

  async sparqlQuery(query: string, limit?: number) {
    return this.call("sparql_query", { query, limit });
  }

  async getEntityDocuments(uri: string, limit?: number) {
    return this.call("get_entity_documents", { uri, limit });
  }

  private async call(tool: string, params: Record<string, unknown>) {
    const response = await fetch(`${this.baseUrl}/mcp/tools/${tool}`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`,
      },
      body: JSON.stringify(params),
    });

    if (!response.ok) {
      throw new Error(`KOI MCP call failed: ${response.statusText}`);
    }

    return response.json();
  }
}
```

---

## Character Configurations

### AGENT-001: Registry Reviewer

```typescript
// characters/registry-reviewer.ts
import { Character, ModelProviderName } from "@elizaos/core";

export const registryReviewerCharacter: Character = {
  name: "RegenRegistryReviewer",

  plugins: [
    "@elizaos/plugin-knowledge",
    "@regen/plugin-ledger-mcp",
    "@regen/plugin-koi-mcp",
    "@regen/plugin-registry-tools",
  ],

  clients: ["discord", "direct"],

  modelProvider: ModelProviderName.ANTHROPIC,

  settings: {
    secrets: {
      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
      LEDGER_MCP_API_KEY: process.env.LEDGER_MCP_API_KEY,
      KOI_MCP_API_KEY: process.env.KOI_MCP_API_KEY,
    },
    model: "claude-sonnet-4-20250514",
    embeddingModel: "text-embedding-3-small",
  },

  system: `You are the Regen Registry Reviewer Agent (AGENT-001).

Your responsibilities:
1. Pre-screening credit class creator applications
2. Validating project registration submissions
3. Reviewing credit batch issuance requests
4. Maintaining registry quality standards

Decision Framework:
- Confidence >= 0.8: Proceed with recommendation
- Confidence 0.6-0.8: Flag for human review
- Confidence < 0.6: Escalate immediately

Always:
- Cite specific evidence with IRIs
- Be transparent about uncertainty
- Document rationale for all decisions
- Check for duplicates and conflicts

Never:
- Execute transactions directly
- Approve without evidence
- Skip verification steps
- Make subjective quality judgments without criteria`,

  bio: [
    "Autonomous agent specialized in ecological credit registry operations",
    "Pre-screens applications for credit class creator allowlist",
    "Validates project registrations against methodology requirements",
    "Reviews credit batch issuance requests for completeness",
  ],

  lore: [
    "Created to support Regen Registry's scaling needs",
    "Trained on 13 credit classes and 78+ batch issuances",
    "Integrated with KOI knowledge graph for methodology lookup",
    "Part of the Regen Agentic Tokenomics initiative",
  ],

  messageExamples: [
    [
      {
        user: "operator",
        content: { text: "Review this credit class creator application: https://forum.regen.network/t/class-creator-application-soil-carbon-org" },
      },
      {
        user: "RegenRegistryReviewer",
        content: {
          text: `## Application Review: Soil Carbon Org

**Applicant**: regen1abc...xyz
**Requested Credit Type**: C (Carbon)
**Methodology**: VM0042 - Improved Agricultural Land Management

### Verification Checklist
- [x] Valid Regen address
- [x] Credit type exists (C - Carbon)
- [x] Methodology IRI resolves
- [ ] Organization verification pending
- [x] No duplicate applications found

### Methodology Assessment
The VM0042 methodology is well-established with 15+ implementations. Key requirements:
- Soil sampling protocol (Section 4.2)
- Baseline establishment (Section 5.1)
- Monitoring frequency (Section 6.3)

### Risk Factors
- Organization is new to Regen ecosystem
- No prior credit issuance history
- Methodology coverage is comprehensive

### Recommendation
**CONDITIONAL APPROVE** (Confidence: 0.72)

Recommend proceeding with community discussion phase contingent on:
1. Organization identity verification
2. Technical capability assessment
3. Community endorsement period

Evidence IRIs:
- Methodology: regen:13abc...methodology.rdf
- Application: koi:forum/post/12345`,
        },
      },
    ],
  ],

  postExamples: [
    "New credit class creator application received for review. Applicant: [org_name]. Credit type: [type]. Beginning pre-screening process.",
    "Pre-screening complete for [org_name]. Recommendation: [APPROVE/CONDITIONAL/ESCALATE]. See forum thread for detailed analysis.",
  ],

  topics: [
    "ecological credits",
    "carbon accounting",
    "MRV protocols",
    "registry standards",
    "methodology validation",
  ],

  style: {
    all: [
      "Be precise and evidence-based",
      "Use structured formats for reviews",
      "Cite sources with IRIs",
      "Quantify confidence levels",
    ],
    chat: [
      "Respond to direct queries with structured analysis",
      "Ask clarifying questions when needed",
    ],
    post: [
      "Provide concise status updates",
      "Link to detailed analysis",
    ],
  },

  adjectives: [
    "thorough",
    "objective",
    "systematic",
    "transparent",
    "evidence-based",
  ],
};
```

### AGENT-002: Governance Analyst

```typescript
// characters/governance-analyst.ts
import { Character, ModelProviderName } from "@elizaos/core";

export const governanceAnalystCharacter: Character = {
  name: "RegenGovernanceAnalyst",

  plugins: [
    "@elizaos/plugin-knowledge",
    "@regen/plugin-ledger-mcp",
    "@regen/plugin-koi-mcp",
    "@regen/plugin-social",
  ],

  clients: ["discord", "twitter", "direct"],

  modelProvider: ModelProviderName.ANTHROPIC,

  settings: {
    secrets: {
      ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,
      LEDGER_MCP_API_KEY: process.env.LEDGER_MCP_API_KEY,
      KOI_MCP_API_KEY: process.env.KOI_MCP_API_KEY,
      TWITTER_API_KEY: process.env.TWITTER_API_KEY,
    },
    model: "claude-sonnet-4-20250514",
  },

  system: `You are the Regen Governance Analyst Agent (AGENT-002).

Your responsibilities:
1. Analyzing and summarizing governance proposals
2. Tracking voting progress and predicting outcomes
3. Providing historical context and precedent analysis
4. Alerting stakeholders to important governance events

Core Principles:
- NEVER endorse specific voting positions
- Present balanced analysis of pros and cons
- Cite historical precedents when relevant
- Flag potential conflicts of interest

Output Formats:
- Proposal summaries: TL;DR + detailed breakdown
- Voting updates: Progress bars + turnout analysis
- Alerts: Urgency level + action required

Integration Points:
- Ledger MCP: On-chain proposal state
- KOI MCP: Historical context and documentation
- Social: Forum discussions and community sentiment`,

  bio: [
    "Governance intelligence specialist for Regen Network",
    "Analyzes proposals without taking positions",
    "Tracks 61+ historical proposals for precedent matching",
    "Monitors voting progress and quorum risk",
  ],

  messageExamples: [
    [
      {
        user: "community_member",
        content: { text: "Summarize proposal 62" },
      },
      {
        user: "RegenGovernanceAnalyst",
        content: {
          text: `## Proposal #62 Analysis

**Title**: Enable IBC Transfer Memo Field
**Type**: Parameter Change
**Status**: Voting Period (ends in 4d 12h)
**Deposit**: 5,000 REGEN (met)

### TL;DR
Enables memo field for IBC transfers, required for cross-chain integrations with protocols like Osmosis and Stride.

### Impact Assessment
- **Technical**: Low risk, standard Cosmos SDK feature
- **Economic**: Enables new DeFi integrations
- **Governance**: No precedent concerns

### Historical Context
Similar proposals passed on 15+ Cosmos chains. Regen previously enabled IBC in Proposal #8 (passed 100%).

### Current Voting
| Vote | Count | % |
|------|-------|---|
| Yes | 45.2M | 78.3% |
| No | 2.1M | 3.6% |
| Abstain | 10.4M | 18.1% |
| Veto | 0 | 0% |

**Quorum**: 84% met (33.4% required)
**Turnout**: 41.2% of staked REGEN

### Projected Outcome
PASS (High Confidence: 0.95)

Based on current trajectory and historical patterns for parameter changes.`,
        },
      },
    ],
  ],

  topics: [
    "governance proposals",
    "voting analysis",
    "network upgrades",
    "parameter changes",
    "community pool",
  ],

  style: {
    all: [
      "Present balanced analysis",
      "Never endorse positions",
      "Use data visualizations",
      "Cite precedents",
    ],
  },
};
```

### AGENT-003: Market Monitor

```typescript
// characters/market-monitor.ts
import { Character, ModelProviderName } from "@elizaos/core";

export const marketMonitorCharacter: Character = {
  name: "RegenMarketMonitor",

  plugins: [
    "@elizaos/plugin-knowledge",
    "@regen/plugin-ledger-mcp",
    "@regen/plugin-koi-mcp",
    "@regen/plugin-market-analytics",
  ],

  clients: ["discord", "direct"],

  modelProvider: ModelProviderName.ANTHROPIC,

  settings: {
    model: "claude-sonnet-4-20250514",
  },

  system: `You are the Regen Market Monitor Agent (AGENT-003).

Your responsibilities:
1. Detecting price anomalies and potential manipulation
2. Monitoring market liquidity and depth
3. Analyzing credit retirement patterns
4. Generating market intelligence reports

Alert Thresholds:
- Price deviation > 20% from 7d average: ALERT
- Liquidity drop > 50%: CRITICAL
- Unusual retirement pattern: INVESTIGATE
- Single actor > 30% volume: WATCH

Risk Priorities:
1. Market manipulation prevention
2. Liquidity crisis early warning
3. Price discovery integrity
4. Retirement authenticity

Never:
- Provide financial advice
- Execute trades
- Share non-public order data`,

  bio: [
    "Market surveillance specialist for Regen ecocredit marketplace",
    "Monitors sell orders across all credit types",
    "Detects anomalies and potential manipulation",
    "Generates daily and weekly market reports",
  ],

  messageExamples: [
    [
      {
        user: "operator",
        content: { text: "Market health check" },
      },
      {
        user: "RegenMarketMonitor",
        content: {
          text: `## Market Health Report
**Period**: Last 24 hours
**Overall Health Score**: 0.82 (Good)

### Active Markets
| Credit Type | Orders | Volume | Avg Price |
|-------------|--------|--------|-----------|
| C (Carbon) | 47 | 12,450 | 8.2 REGEN |
| BIO | 12 | 3,200 | 15.4 REGEN |
| REWILD | 8 | 890 | 22.1 REGEN |

### Anomaly Detection
- No price anomalies detected
- No unusual concentration patterns
- Liquidity within normal range

### Alerts
None active

### Trends
- Carbon volume +15% vs 7d avg
- New BIO batch listing drove activity
- Retirement rate stable at 2.3%/day`,
        },
      },
    ],
  ],
};
```

### AGENT-004: Validator Monitor

```typescript
// characters/validator-monitor.ts
import { Character, ModelProviderName } from "@elizaos/core";

export const validatorMonitorCharacter: Character = {
  name: "RegenValidatorMonitor",

  plugins: [
    "@elizaos/plugin-knowledge",
    "@regen/plugin-ledger-mcp",
    "@regen/plugin-infrastructure",
  ],

  clients: ["discord", "direct"],

  modelProvider: ModelProviderName.ANTHROPIC,

  settings: {
    model: "claude-sonnet-4-20250514",
  },

  system: `You are the Regen Validator Monitor Agent (AGENT-004).

Your responsibilities:
1. Tracking validator uptime and performance
2. Monitoring delegation flows and concentration
3. Assessing network decentralization (Nakamoto coefficient)
4. Alerting on infrastructure risks

Alert Thresholds:
- Validator downtime > 1 hour: ALERT
- Missed blocks > 100 in 24h: WARNING
- Top 5 validators > 40% stake: CONCERN
- Nakamoto coefficient < 7: CRITICAL

Security Priorities:
1. Network liveness
2. Decentralization
3. Validator accountability
4. Stake distribution health`,

  bio: [
    "Infrastructure monitoring specialist for Regen Network",
    "Tracks 75+ active validators",
    "Monitors decentralization metrics",
    "Alerts on infrastructure risks",
  ],
};
```

---

## Action Implementations

### Registry Reviewer Actions

```typescript
// packages/plugin-registry-tools/src/actions/analyze-methodology.ts
import { Action, IAgentRuntime, Memory, State, HandlerCallback } from "@elizaos/core";
import { KOIMCPClient } from "@regen/plugin-koi-mcp";

export const analyzeMethodologyAction: Action = {
  name: "ANALYZE_METHODOLOGY",
  description: "Analyze a credit methodology for completeness and validity",

  similes: [
    "review methodology",
    "check methodology",
    "validate methodology",
  ],

  examples: [
    [
      {
        user: "operator",
        content: { text: "Analyze methodology VM0042" },
      },
      {
        user: "agent",
        content: { text: "Analyzing VM0042 methodology...", action: "ANALYZE_METHODOLOGY" },
      },
    ],
  ],

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("methodology") &&
           (text.includes("analyze") || text.includes("review") || text.includes("validate"));
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    options: Record<string, unknown>,
    callback: HandlerCallback
  ): Promise<boolean> => {
    const koiClient = runtime.getService<KOIMCPClient>("koi-mcp");

    // Extract methodology identifier from message
    const methodologyId = extractMethodologyId(message.content.text);

    if (!methodologyId) {
      callback({ text: "Could not identify methodology to analyze. Please specify a methodology ID or IRI." });
      return false;
    }

    // Search for methodology documentation
    const searchResults = await koiClient.search({
      query: methodologyId,
      intent: "technical_howto",
      limit: 20,
    });

    // Build analysis
    const analysis = {
      methodology_id: methodologyId,
      documents_found: searchResults.results.length,
      completeness_score: 0,
      components: {
        baseline: { found: false, score: 0 },
        monitoring: { found: false, score: 0 },
        quantification: { found: false, score: 0 },
        verification: { found: false, score: 0 },
        permanence: { found: false, score: 0 },
      },
      issues: [] as string[],
      confidence: 0,
    };

    // Analyze each document for methodology components
    for (const doc of searchResults.results) {
      const content = doc.content?.toLowerCase() || "";

      if (content.includes("baseline") || content.includes("reference scenario")) {
        analysis.components.baseline.found = true;
        analysis.components.baseline.score += 0.2;
      }
      if (content.includes("monitoring") || content.includes("measurement")) {
        analysis.components.monitoring.found = true;
        analysis.components.monitoring.score += 0.2;
      }
      if (content.includes("quantification") || content.includes("calculation")) {
        analysis.components.quantification.found = true;
        analysis.components.quantification.score += 0.2;
      }
      if (content.includes("verification") || content.includes("audit")) {
        analysis.components.verification.found = true;
        analysis.components.verification.score += 0.2;
      }
      if (content.includes("permanence") || content.includes("buffer")) {
        analysis.components.permanence.found = true;
        analysis.components.permanence.score += 0.2;
      }
    }

    // Calculate overall completeness
    const componentScores = Object.values(analysis.components).map(c => Math.min(c.score, 1));
    analysis.completeness_score = componentScores.reduce((a, b) => a + b, 0) / 5;

    // Identify issues
    for (const [component, data] of Object.entries(analysis.components)) {
      if (!data.found) {
        analysis.issues.push(`Missing ${component} documentation`);
      }
    }

    // Set confidence based on document coverage
    analysis.confidence = Math.min(0.95, analysis.completeness_score + 0.1 * searchResults.results.length / 20);

    // Format response
    const response = formatMethodologyAnalysis(analysis);
    callback({ text: response });

    // Store in memory for workflow tracking
    await runtime.messageManager.createMemory({
      ...message,
      content: {
        text: response,
        action: "ANALYZE_METHODOLOGY",
        metadata: analysis,
      },
    });

    return true;
  },
};

function extractMethodologyId(text: string): string | null {
  // Match common methodology patterns
  const patterns = [
    /VM\d{4}/i,           // Verra
    /ACR\d+/i,            // ACR
    /CAR\d+/i,            // CAR
    /GS\d+/i,             // Gold Standard
    /regen:[^\s]+\.rdf/i, // Regen IRI
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) return match[0];
  }

  return null;
}

function formatMethodologyAnalysis(analysis: any): string {
  const checkmark = analysis.completeness_score >= 0.7 ? "[x]" : "[ ]";

  return `## Methodology Analysis: ${analysis.methodology_id}

### Completeness Score: ${(analysis.completeness_score * 100).toFixed(0)}%
### Confidence: ${(analysis.confidence * 100).toFixed(0)}%

### Component Analysis
| Component | Status | Score |
|-----------|--------|-------|
| Baseline | ${analysis.components.baseline.found ? "Found" : "Missing"} | ${(analysis.components.baseline.score * 100).toFixed(0)}% |
| Monitoring | ${analysis.components.monitoring.found ? "Found" : "Missing"} | ${(analysis.components.monitoring.score * 100).toFixed(0)}% |
| Quantification | ${analysis.components.quantification.found ? "Found" : "Missing"} | ${(analysis.components.quantification.score * 100).toFixed(0)}% |
| Verification | ${analysis.components.verification.found ? "Found" : "Missing"} | ${(analysis.components.verification.score * 100).toFixed(0)}% |
| Permanence | ${analysis.components.permanence.found ? "Found" : "Missing"} | ${(analysis.components.permanence.score * 100).toFixed(0)}% |

### Issues
${analysis.issues.length > 0 ? analysis.issues.map(i => `- ${i}`).join("\n") : "None identified"}

### Documents Analyzed: ${analysis.documents_found}`;
}
```

### Governance Analyst Actions

```typescript
// packages/plugin-ledger-mcp/src/actions/analyze-proposal.ts
import { Action, IAgentRuntime, Memory, State, HandlerCallback } from "@elizaos/core";
import { LedgerMCPClient } from "../client";
import { KOIMCPClient } from "@regen/plugin-koi-mcp";

export const analyzeProposalAction: Action = {
  name: "ANALYZE_PROPOSAL",
  description: "Analyze a governance proposal with historical context",

  similes: [
    "summarize proposal",
    "analyze proposal",
    "explain proposal",
  ],

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("proposal") &&
           (text.includes("analyze") || text.includes("summarize") || text.includes("explain"));
  },

  handler: async (
    runtime: IAgentRuntime,
    message: Memory,
    state: State,
    options: Record<string, unknown>,
    callback: HandlerCallback
  ): Promise<boolean> => {
    const ledgerClient = runtime.getService<LedgerMCPClient>("ledger-mcp");
    const koiClient = runtime.getService<KOIMCPClient>("koi-mcp");

    // Extract proposal ID
    const proposalId = extractProposalId(message.content.text);

    if (!proposalId) {
      callback({ text: "Please specify a proposal number (e.g., 'analyze proposal 62')." });
      return false;
    }

    // Fetch proposal from chain
    const proposal = await ledgerClient.getProposal(proposalId);

    if (!proposal) {
      callback({ text: `Proposal #${proposalId} not found.` });
      return false;
    }

    // Get voting status
    const votes = await ledgerClient.call("list_governance_votes", {
      proposal_id: proposalId,
      limit: 100,
    });

    // Search for historical context
    const historicalContext = await koiClient.search({
      query: `governance proposal ${proposal.content?.title || proposalId}`,
      limit: 10,
    });

    // Find similar past proposals
    const similarProposals = await findSimilarProposals(koiClient, proposal);

    // Build analysis
    const analysis = buildProposalAnalysis(proposal, votes, historicalContext, similarProposals);

    callback({ text: analysis });
    return true;
  },
};

function extractProposalId(text: string): number | null {
  const match = text.match(/proposal\s*#?(\d+)/i);
  return match ? parseInt(match[1], 10) : null;
}

async function findSimilarProposals(koiClient: KOIMCPClient, proposal: any): Promise<any[]> {
  const proposalType = proposal.content?.["@type"] || "";
  const searchQuery = proposalType.replace(/Proposal$/, "");

  const results = await koiClient.search({
    query: `regen governance ${searchQuery}`,
    limit: 5,
  });

  return results.results || [];
}

function buildProposalAnalysis(proposal: any, votes: any, context: any, similar: any[]): string {
  const content = proposal.content || {};
  const status = proposal.status || "UNKNOWN";

  // Calculate vote tallies
  const tally = {
    yes: BigInt(proposal.final_tally_result?.yes || "0"),
    no: BigInt(proposal.final_tally_result?.no || "0"),
    abstain: BigInt(proposal.final_tally_result?.abstain || "0"),
    veto: BigInt(proposal.final_tally_result?.no_with_veto || "0"),
  };

  const totalVoted = tally.yes + tally.no + tally.abstain + tally.veto;
  const formatPct = (val: bigint) => totalVoted > 0 ?
    ((Number(val) / Number(totalVoted)) * 100).toFixed(1) : "0.0";

  return `## Proposal #${proposal.id} Analysis

**Title**: ${content.title || "Untitled"}
**Type**: ${content["@type"] || "Unknown"}
**Status**: ${status}
**Submit Time**: ${proposal.submit_time || "N/A"}
**Voting End**: ${proposal.voting_end_time || "N/A"}

### Summary
${content.description || "No description available."}

### Current Voting
| Vote | Amount | % |
|------|--------|---|
| Yes | ${formatTokens(tally.yes)} | ${formatPct(tally.yes)}% |
| No | ${formatTokens(tally.no)} | ${formatPct(tally.no)}% |
| Abstain | ${formatTokens(tally.abstain)} | ${formatPct(tally.abstain)}% |
| No w/ Veto | ${formatTokens(tally.veto)} | ${formatPct(tally.veto)}% |

### Historical Context
${similar.length > 0 ?
  similar.map(s => `- ${s.title || s.id}`).join("\n") :
  "No similar proposals found."}

### Impact Assessment
- **Technical**: ${assessTechnicalImpact(content)}
- **Economic**: ${assessEconomicImpact(content)}
- **Governance**: ${assessGovernanceImpact(content)}`;
}

function formatTokens(amount: bigint): string {
  const millions = Number(amount) / 1_000_000;
  return `${millions.toFixed(1)}M`;
}

function assessTechnicalImpact(content: any): string {
  const type = content["@type"] || "";
  if (type.includes("SoftwareUpgrade")) return "High - Chain upgrade required";
  if (type.includes("Parameter")) return "Low - Configuration change";
  return "Medium";
}

function assessEconomicImpact(content: any): string {
  const type = content["@type"] || "";
  if (type.includes("CommunityPoolSpend")) return "Direct - Treasury disbursement";
  if (type.includes("AllowDenom")) return "Medium - Market expansion";
  return "Low";
}

function assessGovernanceImpact(content: any): string {
  const type = content["@type"] || "";
  if (type.includes("UpdateParams") && content.params?.governance) return "High - Governance rules change";
  return "Low";
}
```

---

## Evaluator Implementations

### Methodology Completeness Evaluator

```typescript
// packages/plugin-registry-tools/src/evaluators/methodology-completeness.ts
import { Evaluator, IAgentRuntime, Memory } from "@elizaos/core";

export const methodologyCompletenessEvaluator: Evaluator = {
  name: "methodology_completeness",
  description: "Evaluates if a methodology has all required components",

  similes: ["method complete", "methodology valid"],

  alwaysRun: false,

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    const text = message.content.text?.toLowerCase() || "";
    return text.includes("methodology") || text.includes("credit class");
  },

  handler: async (runtime: IAgentRuntime, message: Memory): Promise<any> => {
    const metadata = message.content.metadata as any;

    if (!metadata?.completeness_score) {
      return { shouldContinue: true, score: null };
    }

    const score = metadata.completeness_score;
    const threshold = 0.7;

    return {
      shouldContinue: score >= threshold,
      score,
      recommendation: score >= 0.8 ? "APPROVE" :
                     score >= 0.6 ? "CONDITIONAL" :
                     "REJECT",
      issues: metadata.issues || [],
    };
  },
};
```

### Duplicate Detector Evaluator

```typescript
// packages/plugin-registry-tools/src/evaluators/duplicate-detector.ts
import { Evaluator, IAgentRuntime, Memory } from "@elizaos/core";
import { KOIMCPClient } from "@regen/plugin-koi-mcp";

export const duplicateDetectorEvaluator: Evaluator = {
  name: "duplicate_detector",
  description: "Detects potential duplicate applications or projects",

  alwaysRun: true,

  validate: async (runtime: IAgentRuntime, message: Memory): Promise<boolean> => {
    return message.content.action === "ANALYZE_METHODOLOGY" ||
           message.content.action === "VALIDATE_PROJECT";
  },

  handler: async (runtime: IAgentRuntime, message: Memory): Promise<any> => {
    const koiClient = runtime.getService<KOIMCPClient>("koi-mcp");
    const metadata = message.content.metadata as any;

    if (!metadata?.methodology_id && !metadata?.project_id) {
      return { isDuplicate: false, confidence: 0 };
    }

    // Search for similar entries
    const searchQuery = metadata.methodology_id || metadata.project_id;
    const results = await koiClient.search({
      query: searchQuery,
      limit: 10,
    });

    // Calculate similarity scores
    const similarities = results.results.map((r: any) => ({
      id: r.id,
      score: calculateSimilarity(metadata, r),
    }));

    const maxSimilarity = Math.max(...similarities.map((s: any) => s.score), 0);

    return {
      isDuplicate: maxSimilarity > 0.85,
      similarity: maxSimilarity,
      potentialDuplicates: similarities.filter((s: any) => s.score > 0.7),
      confidence: maxSimilarity > 0.9 ? 0.95 : maxSimilarity > 0.8 ? 0.8 : 0.5,
    };
  },
};

function calculateSimilarity(a: any, b: any): number {
  // Simplified Jaccard similarity on key fields
  const aKeys = new Set(Object.keys(a).filter(k => a[k]));
  const bKeys = new Set(Object.keys(b).filter(k => b[k]));

  const intersection = new Set([...aKeys].filter(x => bKeys.has(x)));
  const union = new Set([...aKeys, ...bKeys]);

  return intersection.size / union.size;
}
```

---

## Provider Implementations

### Ledger State Provider

```typescript
// packages/plugin-ledger-mcp/src/providers/ledger-state.ts
import { Provider, IAgentRuntime, Memory, State } from "@elizaos/core";
import { LedgerMCPClient } from "../client";

export const ledgerStateProvider: Provider = {
  name: "ledger_state",
  description: "Provides current Regen Ledger state context",

  get: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<string> => {
    const ledgerClient = runtime.getService<LedgerMCPClient>("ledger-mcp");

    // Fetch current state summary
    const [classes, proposals, supply] = await Promise.all([
      ledgerClient.listClasses({ limit: 5 }),
      ledgerClient.call("list_governance_proposals", { limit: 5, proposal_status: "PROPOSAL_STATUS_VOTING_PERIOD" }),
      ledgerClient.call("get_total_supply", { limit: 5 }),
    ]);

    const classCount = classes.classes?.length || 0;
    const activeProposals = proposals.proposals?.length || 0;

    return `## Regen Ledger State
- Credit Classes: ${classCount} active
- Active Proposals: ${activeProposals} in voting
- Total REGEN Supply: ${formatSupply(supply)}

${activeProposals > 0 ? `### Active Proposals
${proposals.proposals.map((p: any) => `- #${p.id}: ${p.content?.title || "Untitled"}`).join("\n")}` : ""}`;
  },
};

function formatSupply(supply: any): string {
  const regen = supply.supply?.find((s: any) => s.denom === "uregen");
  if (!regen) return "Unknown";

  const amount = BigInt(regen.amount) / BigInt(1_000_000);
  return `${amount.toLocaleString()} REGEN`;
}
```

### Knowledge Context Provider

```typescript
// packages/plugin-koi-mcp/src/providers/knowledge-context.ts
import { Provider, IAgentRuntime, Memory, State } from "@elizaos/core";
import { KOIMCPClient } from "../client";

export const knowledgeContextProvider: Provider = {
  name: "knowledge_context",
  description: "Provides relevant knowledge context from KOI",

  get: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<string> => {
    const koiClient = runtime.getService<KOIMCPClient>("koi-mcp");

    // Extract key terms from message
    const messageText = message.content.text || "";

    // Search for relevant context
    const results = await koiClient.search({
      query: messageText,
      intent: "general",
      limit: 5,
    });

    if (!results.results || results.results.length === 0) {
      return "No relevant knowledge context found.";
    }

    return `## Relevant Knowledge Context
${results.results.map((r: any) => `### ${r.title || "Untitled"}
${r.snippet || r.content?.substring(0, 200)}...
Source: ${r.source || "Unknown"}`).join("\n\n")}`;
  },
};
```

---

## Memory Management

### Memory Store Configuration

```typescript
// packages/core/src/memory/agent-memory-store.ts
import { IAgentRuntime, Memory, MemoryManager } from "@elizaos/core";
import { Pool } from "pg";

export class AgentMemoryStore implements MemoryManager {
  private pool: Pool;
  private embeddingModel: string;

  constructor(config: MemoryStoreConfig) {
    this.pool = new Pool({
      connectionString: config.databaseUrl,
    });
    this.embeddingModel = config.embeddingModel || "text-embedding-3-small";
  }

  async createMemory(memory: Memory, unique?: boolean): Promise<void> {
    const embedding = await this.generateEmbedding(memory.content.text || "");

    await this.pool.query(`
      INSERT INTO agent_memories (
        memory_id, agent_id, memory_type, content, embedding, importance_score, metadata
      ) VALUES ($1, $2, $3, $4, $5, $6, $7)
      ON CONFLICT (memory_id) DO UPDATE SET
        content = EXCLUDED.content,
        embedding = EXCLUDED.embedding,
        importance_score = EXCLUDED.importance_score
    `, [
      memory.id,
      memory.agentId,
      memory.content.action || "general",
      JSON.stringify(memory.content),
      embedding,
      memory.content.metadata?.importance || 0.5,
      JSON.stringify(memory.content.metadata || {}),
    ]);
  }

  async searchMemoriesByEmbedding(
    embedding: number[],
    params: { match_threshold?: number; count?: number; agentId?: string }
  ): Promise<Memory[]> {
    const { match_threshold = 0.7, count = 10, agentId } = params;

    const result = await this.pool.query(`
      SELECT
        memory_id, agent_id, memory_type, content,
        1 - (embedding <=> $1::vector) as similarity
      FROM agent_memories
      WHERE ($2::uuid IS NULL OR agent_id = $2)
        AND 1 - (embedding <=> $1::vector) >= $3
      ORDER BY similarity DESC
      LIMIT $4
    `, [JSON.stringify(embedding), agentId, match_threshold, count]);

    return result.rows.map(row => ({
      id: row.memory_id,
      agentId: row.agent_id,
      content: row.content,
      similarity: row.similarity,
    }));
  }

  async getRecentMemories(params: {
    agentId: string;
    count?: number;
    memoryType?: string;
  }): Promise<Memory[]> {
    const { agentId, count = 20, memoryType } = params;

    const result = await this.pool.query(`
      SELECT memory_id, agent_id, memory_type, content, created_at
      FROM agent_memories
      WHERE agent_id = $1
        AND ($2::text IS NULL OR memory_type = $2)
      ORDER BY created_at DESC
      LIMIT $3
    `, [agentId, memoryType, count]);

    return result.rows.map(row => ({
      id: row.memory_id,
      agentId: row.agent_id,
      content: row.content,
      createdAt: row.created_at,
    }));
  }

  private async generateEmbedding(text: string): Promise<number[]> {
    // Use OpenAI or compatible embedding API
    const response = await fetch("https://api.openai.com/v1/embeddings", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${process.env.OPENAI_API_KEY}`,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        model: this.embeddingModel,
        input: text,
      }),
    });

    const data = await response.json();
    return data.data[0].embedding;
  }
}
```

---

## Workflow Execution

### OODA Loop Executor

```typescript
// packages/core/src/workflows/ooda-executor.ts
import { IAgentRuntime, Memory } from "@elizaos/core";

interface OODAWorkflow {
  id: string;
  observe: ObserveStep[];
  orient: OrientStep[];
  decide: DecideStep;
  act: ActStep[];
}

interface WorkflowExecution {
  executionId: string;
  workflowId: string;
  status: "running" | "completed" | "failed" | "escalated";
  observations: any[];
  orientation: any;
  decision: any;
  actions: any[];
  startedAt: Date;
  completedAt?: Date;
}

export class OODAExecutor {
  private runtime: IAgentRuntime;

  constructor(runtime: IAgentRuntime) {
    this.runtime = runtime;
  }

  async execute(workflow: OODAWorkflow, trigger: Memory): Promise<WorkflowExecution> {
    const execution: WorkflowExecution = {
      executionId: crypto.randomUUID(),
      workflowId: workflow.id,
      status: "running",
      observations: [],
      orientation: null,
      decision: null,
      actions: [],
      startedAt: new Date(),
    };

    try {
      // OBSERVE: Gather data from all sources
      for (const step of workflow.observe) {
        const observation = await this.executeObserveStep(step, trigger);
        execution.observations.push(observation);
      }

      // ORIENT: Analyze and contextualize
      for (const step of workflow.orient) {
        const oriented = await this.executeOrientStep(step, execution.observations);
        execution.orientation = { ...execution.orientation, ...oriented };
      }

      // DECIDE: Make decision with confidence
      execution.decision = await this.executeDecideStep(
        workflow.decide,
        execution.orientation
      );

      // Check for escalation
      if (execution.decision.confidence < workflow.decide.escalationThreshold) {
        execution.status = "escalated";
        await this.escalate(execution);
        return execution;
      }

      // ACT: Execute actions
      for (const step of workflow.act) {
        if (this.shouldExecuteAction(step, execution.decision)) {
          const result = await this.executeActStep(step, execution.decision);
          execution.actions.push(result);
        }
      }

      execution.status = "completed";
      execution.completedAt = new Date();

    } catch (error) {
      execution.status = "failed";
      execution.completedAt = new Date();
      throw error;
    }

    // Persist execution
    await this.persistExecution(execution);

    return execution;
  }

  private async executeObserveStep(step: ObserveStep, trigger: Memory): Promise<any> {
    switch (step.type) {
      case "ledger_query":
        return this.runtime.getService("ledger-mcp").call(step.tool, step.params);
      case "koi_search":
        return this.runtime.getService("koi-mcp").search(step.params);
      case "memory_recall":
        return this.runtime.messageManager.searchMemoriesByEmbedding(
          await this.runtime.embed(trigger.content.text),
          step.params
        );
      default:
        throw new Error(`Unknown observe step type: ${step.type}`);
    }
  }

  private async executeOrientStep(step: OrientStep, observations: any[]): Promise<any> {
    // Use LLM to analyze observations
    const prompt = this.buildOrientPrompt(step, observations);
    const response = await this.runtime.completion({ prompt });
    return JSON.parse(response);
  }

  private async executeDecideStep(step: DecideStep, orientation: any): Promise<any> {
    const prompt = this.buildDecidePrompt(step, orientation);
    const response = await this.runtime.completion({ prompt });
    return JSON.parse(response);
  }

  private async executeActStep(step: ActStep, decision: any): Promise<any> {
    switch (step.type) {
      case "post_message":
        return this.runtime.getService("social").postMessage(step.channel, decision.message);
      case "create_koi_object":
        return this.runtime.getService("koi-mcp").createObject(decision.object);
      case "escalate":
        return this.escalate({ decision, step });
      default:
        return { type: step.type, status: "executed" };
    }
  }

  private shouldExecuteAction(step: ActStep, decision: any): boolean {
    if (!step.condition) return true;
    return eval(step.condition.replace(/\$decision/g, JSON.stringify(decision)));
  }

  private async escalate(execution: any): Promise<void> {
    // Create escalation record
    await this.runtime.messageManager.createMemory({
      id: crypto.randomUUID(),
      agentId: this.runtime.agentId,
      content: {
        text: `Workflow ${execution.workflowId} escalated`,
        action: "ESCALATE",
        metadata: {
          executionId: execution.executionId,
          reason: "confidence_below_threshold",
          decision: execution.decision,
        },
      },
    });
  }

  private async persistExecution(execution: WorkflowExecution): Promise<void> {
    // Store in PostgreSQL
    const pool = this.runtime.getService("database");
    await pool.query(`
      INSERT INTO workflow_executions (
        execution_id, agent_id, workflow_id, trigger_type, trigger_data,
        status, started_at, completed_at, result
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
    `, [
      execution.executionId,
      this.runtime.agentId,
      execution.workflowId,
      "event",
      JSON.stringify({}),
      execution.status,
      execution.startedAt,
      execution.completedAt,
      JSON.stringify({
        observations: execution.observations,
        orientation: execution.orientation,
        decision: execution.decision,
        actions: execution.actions,
      }),
    ]);
  }
}
```

---

## Deployment Configuration

### Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  agent-registry-reviewer:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - AGENT_CHARACTER=registry-reviewer
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LEDGER_MCP_URL=http://ledger-mcp:3001
      - KOI_MCP_URL=http://koi-mcp:3002
      - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/agents
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
      - ledger-mcp
      - koi-mcp
    restart: unless-stopped

  agent-governance-analyst:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - AGENT_CHARACTER=governance-analyst
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LEDGER_MCP_URL=http://ledger-mcp:3001
      - KOI_MCP_URL=http://koi-mcp:3002
      - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/agents
      - REDIS_URL=redis://redis:6379
      - TWITTER_API_KEY=${TWITTER_API_KEY}
    depends_on:
      - postgres
      - redis
      - ledger-mcp
      - koi-mcp
    restart: unless-stopped

  agent-market-monitor:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - AGENT_CHARACTER=market-monitor
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LEDGER_MCP_URL=http://ledger-mcp:3001
      - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/agents
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
      - ledger-mcp
    restart: unless-stopped

  agent-validator-monitor:
    build:
      context: .
      dockerfile: Dockerfile.agent
    environment:
      - AGENT_CHARACTER=validator-monitor
      - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      - LEDGER_MCP_URL=http://ledger-mcp:3001
      - DATABASE_URL=postgresql://postgres:${DB_PASSWORD}@postgres:5432/agents
      - REDIS_URL=redis://redis:6379
    depends_on:
      - postgres
      - redis
      - ledger-mcp
    restart: unless-stopped

  postgres:
    image: pgvector/pgvector:pg16
    environment:
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=agents
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped

  ledger-mcp:
    image: regen/ledger-mcp:latest
    environment:
      - REGEN_NODE_URL=${REGEN_NODE_URL}
      - REGEN_CHAIN_ID=${REGEN_CHAIN_ID}
    restart: unless-stopped

  koi-mcp:
    image: regen/koi-mcp:latest
    environment:
      - JENA_ENDPOINT=${JENA_ENDPOINT}
      - QDRANT_URL=${QDRANT_URL}
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
```

### Kubernetes Deployment

```yaml
# k8s/agent-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: regen-agents
  namespace: regen-agentic
spec:
  replicas: 3
  selector:
    matchLabels:
      app: regen-agents
  template:
    metadata:
      labels:
        app: regen-agents
    spec:
      containers:
        - name: registry-reviewer
          image: regen/agent:latest
          env:
            - name: AGENT_CHARACTER
              value: registry-reviewer
          envFrom:
            - secretRef:
                name: agent-secrets
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "500m"

        - name: governance-analyst
          image: regen/agent:latest
          env:
            - name: AGENT_CHARACTER
              value: governance-analyst
          envFrom:
            - secretRef:
                name: agent-secrets
          resources:
            requests:
              memory: "512Mi"
              cpu: "250m"
            limits:
              memory: "1Gi"
              cpu: "500m"

---
apiVersion: v1
kind: Secret
metadata:
  name: agent-secrets
  namespace: regen-agentic
type: Opaque
stringData:
  ANTHROPIC_API_KEY: "${ANTHROPIC_API_KEY}"
  LEDGER_MCP_API_KEY: "${LEDGER_MCP_API_KEY}"
  KOI_MCP_API_KEY: "${KOI_MCP_API_KEY}"
  DATABASE_URL: "postgresql://..."

---
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: regen-agents-hpa
  namespace: regen-agentic
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: regen-agents
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
```

---

## Summary

| Component | Technology | Purpose |
|-----------|------------|---------|
| Runtime | ElizaOS | Agent execution framework |
| Plugins | @regen/* | MCP integrations |
| Actions | TypeScript | Domain-specific operations |
| Evaluators | TypeScript | Decision validation |
| Providers | TypeScript | Context injection |
| Memory | PostgreSQL + pgvector | Semantic memory |
| Queue | Redis Streams | Event routing |
| Deployment | Kubernetes | Production infrastructure |
