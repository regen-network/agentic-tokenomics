# Phase 3.1: Smart Contract Development Specifications

## Overview

This document provides implementation-ready specifications for smart contracts supporting the agentic tokenomics system. Contracts are divided between native Cosmos SDK module extensions and CosmWasm smart contracts.

---

## Contract Architecture

```
┌─────────────────────────────────────────────────────────────────────────┐
│                         REGEN LEDGER                                     │
├─────────────────────────────────────────────────────────────────────────┤
│  NATIVE MODULES (Cosmos SDK)                                            │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐         │
│  │ x/ecocredit     │  │ x/data          │  │ x/gov           │         │
│  │ (enhanced)      │  │                 │  │                 │         │
│  │ - AgentScoring  │  │ - Attestations  │  │ - Proposals     │         │
│  │ - ClassProposal │  │ - IRIs          │  │ - Voting        │         │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘         │
├─────────────────────────────────────────────────────────────────────────┤
│  COSMWASM CONTRACTS                                                      │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐         │
│  │ attestation-    │  │ service-        │  │ reputation-     │         │
│  │ bond            │  │ escrow          │  │ registry        │         │
│  │ (M008)          │  │ (M009)          │  │ (M010)          │         │
│  └─────────────────┘  └─────────────────┘  └─────────────────┘         │
│  ┌─────────────────┐  ┌─────────────────┐                              │
│  │ marketplace-    │  │ arbiter-dao     │                              │
│  │ curation        │  │ (DAO DAO)       │                              │
│  │ (M011)          │  │                 │                              │
│  └─────────────────┘  └─────────────────┘                              │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## Native Module: x/ecocredit Enhancement (M001-ENH)

### New Message Types

```protobuf
// proto/regen/ecocredit/v1/tx.proto

// MsgProposeClassCreator submits a credit class creator application
// with optional agent pre-screening
message MsgProposeClassCreator {
  option (cosmos.msg.v1.signer) = "proposer";

  // proposer is the address submitting the application
  string proposer = 1;

  // credit_type is the type of credits (e.g., "C" for carbon)
  string credit_type = 2;

  // methodology_iri points to the methodology document
  string methodology_iri = 3;

  // admin_address will be the class admin if approved
  string admin_address = 4;

  // metadata contains additional application data
  string metadata = 5;

  // deposit is the required application deposit
  repeated cosmos.base.v1beta1.Coin deposit = 6;
}

// MsgProposeClassCreatorResponse returns the proposal ID
message MsgProposeClassCreatorResponse {
  uint64 proposal_id = 1;
}

// MsgSubmitAgentScore allows authorized agents to submit pre-screening scores
message MsgSubmitAgentScore {
  option (cosmos.msg.v1.signer) = "agent";

  // agent is the authorized agent address
  string agent = 1;

  // proposal_id is the class creator proposal being scored
  uint64 proposal_id = 2;

  // score is the agent's assessment (0-1000, representing 0.000-1.000)
  uint32 score = 3;

  // confidence is the agent's confidence level (0-1000)
  uint32 confidence = 4;

  // recommendation is APPROVE, CONDITIONAL, or REJECT
  string recommendation = 5;

  // rationale_iri points to detailed analysis
  string rationale_iri = 6;
}
```

### New State Objects

```protobuf
// proto/regen/ecocredit/v1/state.proto

// ClassCreatorProposal tracks a credit class creator application
message ClassCreatorProposal {
  // id is the unique proposal identifier
  uint64 id = 1;

  // proposer is the applicant address
  string proposer = 2;

  // credit_type requested
  string credit_type = 3;

  // methodology_iri
  string methodology_iri = 4;

  // admin_address proposed
  string admin_address = 5;

  // status is PENDING_REVIEW, AGENT_REVIEWED, VOTING, APPROVED, REJECTED
  string status = 6;

  // deposit amount locked
  repeated cosmos.base.v1beta1.Coin deposit = 7;

  // agent_score if submitted
  AgentScore agent_score = 8;

  // governance_proposal_id if promoted to governance
  uint64 governance_proposal_id = 9;

  // submit_time
  google.protobuf.Timestamp submit_time = 10;

  // decision_time
  google.protobuf.Timestamp decision_time = 11;
}

// AgentScore records an agent's pre-screening assessment
message AgentScore {
  string agent = 1;
  uint32 score = 2;        // 0-1000 (0.000-1.000)
  uint32 confidence = 3;   // 0-1000
  string recommendation = 4;
  string rationale_iri = 5;
  google.protobuf.Timestamp scored_at = 6;
}
```

### Keeper Implementation

```go
// x/ecocredit/keeper/msg_server_class_creator.go

package keeper

import (
    "context"
    sdk "github.com/cosmos/cosmos-sdk/types"
    "github.com/regen-network/regen-ledger/x/ecocredit/v3/base"
)

// ProposeClassCreator handles MsgProposeClassCreator
func (k Keeper) ProposeClassCreator(
    ctx context.Context,
    msg *base.MsgProposeClassCreator,
) (*base.MsgProposeClassCreatorResponse, error) {
    sdkCtx := sdk.UnwrapSDKContext(ctx)

    // Validate credit type exists
    if !k.creditTypeExists(ctx, msg.CreditType) {
        return nil, ErrInvalidCreditType
    }

    // Validate deposit meets minimum
    minDeposit := k.GetClassCreatorMinDeposit(ctx)
    if !msg.Deposit.IsAllGTE(minDeposit) {
        return nil, ErrInsufficientDeposit
    }

    // Lock deposit in escrow
    proposer, err := sdk.AccAddressFromBech32(msg.Proposer)
    if err != nil {
        return nil, err
    }
    if err := k.bankKeeper.SendCoinsFromAccountToModule(
        ctx, proposer, base.ModuleName, msg.Deposit,
    ); err != nil {
        return nil, err
    }

    // Create proposal
    proposalID := k.getNextProposalID(ctx)
    proposal := &base.ClassCreatorProposal{
        Id:             proposalID,
        Proposer:       msg.Proposer,
        CreditType:     msg.CreditType,
        MethodologyIri: msg.MethodologyIri,
        AdminAddress:   msg.AdminAddress,
        Status:         "PENDING_REVIEW",
        Deposit:        msg.Deposit,
        SubmitTime:     sdkCtx.BlockTime(),
    }

    k.setClassCreatorProposal(ctx, proposal)

    // Emit event
    sdkCtx.EventManager().EmitEvent(
        sdk.NewEvent(
            "class_creator_proposed",
            sdk.NewAttribute("proposal_id", fmt.Sprintf("%d", proposalID)),
            sdk.NewAttribute("proposer", msg.Proposer),
            sdk.NewAttribute("credit_type", msg.CreditType),
        ),
    )

    return &base.MsgProposeClassCreatorResponse{
        ProposalId: proposalID,
    }, nil
}

// SubmitAgentScore handles MsgSubmitAgentScore
func (k Keeper) SubmitAgentScore(
    ctx context.Context,
    msg *base.MsgSubmitAgentScore,
) (*base.MsgSubmitAgentScoreResponse, error) {
    sdkCtx := sdk.UnwrapSDKContext(ctx)

    // Verify agent is authorized
    if !k.isAuthorizedAgent(ctx, msg.Agent) {
        return nil, ErrUnauthorizedAgent
    }

    // Get proposal
    proposal, err := k.getClassCreatorProposal(ctx, msg.ProposalId)
    if err != nil {
        return nil, err
    }

    // Verify proposal is in correct state
    if proposal.Status != "PENDING_REVIEW" {
        return nil, ErrInvalidProposalStatus
    }

    // Record agent score
    proposal.AgentScore = &base.AgentScore{
        Agent:         msg.Agent,
        Score:         msg.Score,
        Confidence:    msg.Confidence,
        Recommendation: msg.Recommendation,
        RationaleIri:  msg.RationaleIri,
        ScoredAt:      sdkCtx.BlockTime(),
    }
    proposal.Status = "AGENT_REVIEWED"

    k.setClassCreatorProposal(ctx, proposal)

    // Auto-promote to governance if score high enough
    if msg.Score >= 700 && msg.Confidence >= 850 {
        k.promoteToGovernance(ctx, proposal)
    }

    return &base.MsgSubmitAgentScoreResponse{}, nil
}
```

---

## CosmWasm Contract: Attestation Bond (M008)

### Contract State

```rust
// contracts/attestation-bond/src/state.rs

use cosmwasm_std::{Addr, Coin, Timestamp, Uint128};
use cw_storage_plus::{Item, Map};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Config {
    pub admin: Addr,
    pub arbiter_dao: Addr,
    pub min_challenge_deposit_ratio: Uint128,  // basis points (e.g., 1000 = 10%)
    pub challenge_period_days: u64,
    pub arbiter_fee_ratio: Uint128,  // basis points
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct AttestationType {
    pub name: String,
    pub min_bond: Uint128,
    pub lock_period_days: u64,
    pub challenge_window_days: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum BondStatus {
    Bonded,
    Active,
    Challenged,
    ResolvedValid,
    ResolvedInvalid,
    Released,
    Slashed,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Attestation {
    pub id: u64,
    pub attester: Addr,
    pub attestation_type: String,
    pub attestation_iri: String,
    pub beneficiary: Option<Addr>,
    pub bond: Coin,
    pub status: BondStatus,
    pub bonded_at: Timestamp,
    pub activated_at: Option<Timestamp>,
    pub lock_expires_at: Timestamp,
    pub challenge_window_closes_at: Timestamp,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Challenge {
    pub id: u64,
    pub attestation_id: u64,
    pub challenger: Addr,
    pub evidence_iri: String,
    pub deposit: Coin,
    pub status: ChallengeStatus,
    pub created_at: Timestamp,
    pub resolved_at: Option<Timestamp>,
    pub resolution: Option<ChallengeResolution>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ChallengeStatus {
    Pending,
    Voting,
    Resolved,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum ChallengeResolution {
    AttesterWins,
    ChallengerWins,
}

pub const CONFIG: Item<Config> = Item::new("config");
pub const ATTESTATION_TYPES: Map<&str, AttestationType> = Map::new("attestation_types");
pub const ATTESTATIONS: Map<u64, Attestation> = Map::new("attestations");
pub const CHALLENGES: Map<u64, Challenge> = Map::new("challenges");
pub const NEXT_ATTESTATION_ID: Item<u64> = Item::new("next_attestation_id");
pub const NEXT_CHALLENGE_ID: Item<u64> = Item::new("next_challenge_id");
```

### Contract Messages

```rust
// contracts/attestation-bond/src/msg.rs

use cosmwasm_std::{Coin, Uint128};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct InstantiateMsg {
    pub arbiter_dao: String,
    pub min_challenge_deposit_ratio: Uint128,
    pub challenge_period_days: u64,
    pub arbiter_fee_ratio: Uint128,
    pub attestation_types: Vec<AttestationTypeInput>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct AttestationTypeInput {
    pub name: String,
    pub min_bond: Uint128,
    pub lock_period_days: u64,
    pub challenge_window_days: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    // Create a new bonded attestation
    CreateAttestation {
        attestation_type: String,
        attestation_iri: String,
        beneficiary: Option<String>,
    },

    // Challenge an existing attestation
    ChallengeAttestation {
        attestation_id: u64,
        evidence_iri: String,
    },

    // Submit arbiter DAO resolution (called by arbiter DAO)
    ResolveChallenge {
        challenge_id: u64,
        resolution: ChallengeResolutionInput,
    },

    // Release bond after lock period (called by attester)
    ReleaseBond {
        attestation_id: u64,
    },

    // Admin functions
    UpdateConfig {
        arbiter_dao: Option<String>,
        min_challenge_deposit_ratio: Option<Uint128>,
    },

    AddAttestationType {
        attestation_type: AttestationTypeInput,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ChallengeResolutionInput {
    AttesterWins,
    ChallengerWins,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum QueryMsg {
    Config {},
    Attestation { id: u64 },
    AttestationsByAttester { attester: String, start_after: Option<u64>, limit: Option<u32> },
    Challenge { id: u64 },
    ChallengesByAttestation { attestation_id: u64 },
    AttestationType { name: String },
    AllAttestationTypes {},
}
```

### Core Contract Logic

```rust
// contracts/attestation-bond/src/contract.rs

use cosmwasm_std::{
    entry_point, to_binary, BankMsg, Binary, Coin, CosmosMsg, Deps, DepsMut,
    Env, MessageInfo, Response, StdResult, Uint128,
};

use crate::error::ContractError;
use crate::msg::{ExecuteMsg, InstantiateMsg, QueryMsg};
use crate::state::{
    Attestation, AttestationType, BondStatus, Challenge, ChallengeStatus,
    Config, ATTESTATIONS, ATTESTATION_TYPES, CHALLENGES, CONFIG,
    NEXT_ATTESTATION_ID, NEXT_CHALLENGE_ID,
};

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::CreateAttestation {
            attestation_type,
            attestation_iri,
            beneficiary,
        } => execute_create_attestation(
            deps, env, info, attestation_type, attestation_iri, beneficiary,
        ),
        ExecuteMsg::ChallengeAttestation {
            attestation_id,
            evidence_iri,
        } => execute_challenge_attestation(deps, env, info, attestation_id, evidence_iri),
        ExecuteMsg::ResolveChallenge {
            challenge_id,
            resolution,
        } => execute_resolve_challenge(deps, env, info, challenge_id, resolution),
        ExecuteMsg::ReleaseBond { attestation_id } => {
            execute_release_bond(deps, env, info, attestation_id)
        }
        // ... other handlers
    }
}

fn execute_create_attestation(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    attestation_type: String,
    attestation_iri: String,
    beneficiary: Option<String>,
) -> Result<Response, ContractError> {
    // Load attestation type config
    let att_type = ATTESTATION_TYPES
        .load(deps.storage, &attestation_type)
        .map_err(|_| ContractError::UnknownAttestationType {})?;

    // Validate bond amount
    let bond = info
        .funds
        .iter()
        .find(|c| c.denom == "uregen")
        .ok_or(ContractError::NoBondProvided {})?;

    if bond.amount < att_type.min_bond {
        return Err(ContractError::InsufficientBond {
            required: att_type.min_bond,
            provided: bond.amount,
        });
    }

    // Calculate timestamps
    let lock_expires = env.block.time.plus_days(att_type.lock_period_days);
    let challenge_closes = env.block.time.plus_days(att_type.challenge_window_days);

    // Create attestation
    let id = NEXT_ATTESTATION_ID.load(deps.storage).unwrap_or(1);
    let attestation = Attestation {
        id,
        attester: info.sender.clone(),
        attestation_type,
        attestation_iri,
        beneficiary: beneficiary.map(|b| deps.api.addr_validate(&b)).transpose()?,
        bond: bond.clone(),
        status: BondStatus::Bonded,
        bonded_at: env.block.time,
        activated_at: None,
        lock_expires_at: lock_expires,
        challenge_window_closes_at: challenge_closes,
    };

    ATTESTATIONS.save(deps.storage, id, &attestation)?;
    NEXT_ATTESTATION_ID.save(deps.storage, &(id + 1))?;

    Ok(Response::new()
        .add_attribute("action", "create_attestation")
        .add_attribute("attestation_id", id.to_string())
        .add_attribute("attester", info.sender)
        .add_attribute("bond_amount", bond.amount))
}

fn execute_challenge_attestation(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    attestation_id: u64,
    evidence_iri: String,
) -> Result<Response, ContractError> {
    let config = CONFIG.load(deps.storage)?;
    let mut attestation = ATTESTATIONS.load(deps.storage, attestation_id)?;

    // Verify attestation can be challenged
    if attestation.status != BondStatus::Active {
        return Err(ContractError::AttestationNotChallengeable {});
    }

    if env.block.time > attestation.challenge_window_closes_at {
        return Err(ContractError::ChallengeWindowClosed {});
    }

    // Validate challenge deposit (10% of bond)
    let min_deposit = attestation.bond.amount
        .multiply_ratio(config.min_challenge_deposit_ratio, Uint128::from(10000u128));

    let deposit = info
        .funds
        .iter()
        .find(|c| c.denom == attestation.bond.denom)
        .ok_or(ContractError::NoDepositProvided {})?;

    if deposit.amount < min_deposit {
        return Err(ContractError::InsufficientChallengeDeposit {});
    }

    // Create challenge
    let challenge_id = NEXT_CHALLENGE_ID.load(deps.storage).unwrap_or(1);
    let challenge = Challenge {
        id: challenge_id,
        attestation_id,
        challenger: info.sender.clone(),
        evidence_iri,
        deposit: deposit.clone(),
        status: ChallengeStatus::Pending,
        created_at: env.block.time,
        resolved_at: None,
        resolution: None,
    };

    CHALLENGES.save(deps.storage, challenge_id, &challenge)?;
    NEXT_CHALLENGE_ID.save(deps.storage, &(challenge_id + 1))?;

    // Update attestation status
    attestation.status = BondStatus::Challenged;
    ATTESTATIONS.save(deps.storage, attestation_id, &attestation)?;

    // Notify arbiter DAO (via submessage to DAO DAO)
    let notify_msg = create_arbiter_proposal_msg(&config.arbiter_dao, &challenge)?;

    Ok(Response::new()
        .add_message(notify_msg)
        .add_attribute("action", "challenge_attestation")
        .add_attribute("challenge_id", challenge_id.to_string())
        .add_attribute("attestation_id", attestation_id.to_string())
        .add_attribute("challenger", info.sender))
}

fn execute_resolve_challenge(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    challenge_id: u64,
    resolution: ChallengeResolutionInput,
) -> Result<Response, ContractError> {
    let config = CONFIG.load(deps.storage)?;

    // Only arbiter DAO can resolve
    if info.sender != config.arbiter_dao {
        return Err(ContractError::Unauthorized {});
    }

    let mut challenge = CHALLENGES.load(deps.storage, challenge_id)?;
    let mut attestation = ATTESTATIONS.load(deps.storage, challenge.attestation_id)?;

    // Calculate distributions
    let arbiter_fee = attestation.bond.amount
        .multiply_ratio(config.arbiter_fee_ratio, Uint128::from(10000u128));

    let mut messages: Vec<CosmosMsg> = vec![];

    match resolution {
        ChallengeResolutionInput::AttesterWins => {
            // Attester gets bond + challenge deposit - arbiter fee
            let attester_amount = attestation.bond.amount
                .checked_add(challenge.deposit.amount)?
                .checked_sub(arbiter_fee)?;

            messages.push(CosmosMsg::Bank(BankMsg::Send {
                to_address: attestation.attester.to_string(),
                amount: vec![Coin {
                    denom: attestation.bond.denom.clone(),
                    amount: attester_amount,
                }],
            }));

            attestation.status = BondStatus::ResolvedValid;
            challenge.resolution = Some(ChallengeResolution::AttesterWins);
        }
        ChallengeResolutionInput::ChallengerWins => {
            // Challenger gets 50% of bond + deposit - arbiter fee
            let challenger_amount = attestation.bond.amount
                .multiply_ratio(Uint128::from(50u128), Uint128::from(100u128))
                .checked_add(challenge.deposit.amount)?
                .checked_sub(arbiter_fee)?;

            // Community pool gets remaining 50%
            let community_amount = attestation.bond.amount
                .multiply_ratio(Uint128::from(50u128), Uint128::from(100u128));

            messages.push(CosmosMsg::Bank(BankMsg::Send {
                to_address: challenge.challenger.to_string(),
                amount: vec![Coin {
                    denom: attestation.bond.denom.clone(),
                    amount: challenger_amount,
                }],
            }));

            // Send to community pool (via distribution module)
            // This requires a custom message to x/distribution

            attestation.status = BondStatus::Slashed;
            challenge.resolution = Some(ChallengeResolution::ChallengerWins);
        }
    }

    // Send arbiter fee
    messages.push(CosmosMsg::Bank(BankMsg::Send {
        to_address: config.arbiter_dao.to_string(),
        amount: vec![Coin {
            denom: attestation.bond.denom.clone(),
            amount: arbiter_fee,
        }],
    }));

    challenge.status = ChallengeStatus::Resolved;
    challenge.resolved_at = Some(env.block.time);

    CHALLENGES.save(deps.storage, challenge_id, &challenge)?;
    ATTESTATIONS.save(deps.storage, challenge.attestation_id, &attestation)?;

    Ok(Response::new()
        .add_messages(messages)
        .add_attribute("action", "resolve_challenge")
        .add_attribute("challenge_id", challenge_id.to_string())
        .add_attribute("resolution", format!("{:?}", resolution)))
}
```

---

## CosmWasm Contract: Service Escrow (M009)

### Contract State

```rust
// contracts/service-escrow/src/state.rs

use cosmwasm_std::{Addr, Coin, Timestamp, Uint128};
use cw_storage_plus::{Item, Map};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Config {
    pub admin: Addr,
    pub arbiter_dao: Addr,
    pub provider_bond_ratio: Uint128,  // basis points (e.g., 1000 = 10%)
    pub default_review_period_days: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum AgreementStatus {
    Proposed,
    Funded,
    InProgress,
    Completed,
    Disputed,
    Cancelled,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ServiceAgreement {
    pub id: u64,
    pub client: Addr,
    pub provider: Addr,
    pub service_type: String,
    pub description: String,
    pub escrow_amount: Coin,
    pub provider_bond: Coin,
    pub milestones: Vec<Milestone>,
    pub current_milestone: u32,
    pub status: AgreementStatus,
    pub created_at: Timestamp,
    pub started_at: Option<Timestamp>,
    pub completed_at: Option<Timestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Milestone {
    pub index: u32,
    pub description: String,
    pub payment: Coin,
    pub due_date: Option<Timestamp>,
    pub status: MilestoneStatus,
    pub deliverable_iri: Option<String>,
    pub submitted_at: Option<Timestamp>,
    pub approved_at: Option<Timestamp>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum MilestoneStatus {
    Pending,
    InProgress,
    Submitted,
    Approved,
    Disputed,
}

pub const CONFIG: Item<Config> = Item::new("config");
pub const AGREEMENTS: Map<u64, ServiceAgreement> = Map::new("agreements");
pub const NEXT_AGREEMENT_ID: Item<u64> = Item::new("next_agreement_id");
```

### Contract Messages

```rust
// contracts/service-escrow/src/msg.rs

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    // Client proposes a service agreement
    ProposeAgreement {
        provider: String,
        service_type: String,
        description: String,
        milestones: Vec<MilestoneInput>,
    },

    // Provider accepts and posts bond
    AcceptAgreement {
        agreement_id: u64,
    },

    // Client funds the escrow
    FundAgreement {
        agreement_id: u64,
    },

    // Provider submits milestone deliverable
    SubmitMilestone {
        agreement_id: u64,
        milestone_index: u32,
        deliverable_iri: String,
    },

    // Client approves milestone
    ApproveMilestone {
        agreement_id: u64,
        milestone_index: u32,
    },

    // Client disputes milestone
    DisputeMilestone {
        agreement_id: u64,
        milestone_index: u32,
        reason: String,
    },

    // Arbiter resolves dispute
    ResolveDispute {
        agreement_id: u64,
        milestone_index: u32,
        resolution: DisputeResolution,
    },

    // Cancel agreement (before start)
    CancelAgreement {
        agreement_id: u64,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct MilestoneInput {
    pub description: String,
    pub payment_amount: Uint128,
    pub due_days: Option<u64>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum DisputeResolution {
    ClientWins,
    ProviderWins,
    Split { client_percent: u32 },
}
```

---

## CosmWasm Contract: Reputation Registry (M010)

### Contract State

```rust
// contracts/reputation-registry/src/state.rs

use cosmwasm_std::{Addr, Timestamp, Uint128};
use cw_storage_plus::{Item, Map, IndexedMap, Index, IndexList, MultiIndex};
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct Config {
    pub admin: Addr,
    pub staking_contract: Addr,  // x/staking query interface
    pub decay_half_life_days: u64,
    pub min_stake_by_category: Vec<(String, Uint128)>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct ReputationSignal {
    pub id: u64,
    pub signaler: Addr,
    pub subject_type: SubjectType,
    pub subject_id: String,
    pub category: String,
    pub endorsement_level: u8,  // 1-5
    pub rationale_iri: Option<String>,
    pub stake_at_signal: Uint128,
    pub created_at: Timestamp,
    pub status: SignalStatus,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum SubjectType {
    CreditClass,
    Project,
    Verifier,
    Methodology,
    Address,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub enum SignalStatus {
    Active,
    Withdrawn,
    Challenged,
    Invalidated,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct AggregatedReputation {
    pub subject_type: SubjectType,
    pub subject_id: String,
    pub category: String,
    pub score: Uint128,  // Fixed point (multiply by 1000)
    pub signal_count: u32,
    pub last_updated: Timestamp,
}

pub const CONFIG: Item<Config> = Item::new("config");
pub const SIGNALS: Map<u64, ReputationSignal> = Map::new("signals");
pub const AGGREGATED: Map<(&str, &str, &str), AggregatedReputation> = Map::new("aggregated");
pub const NEXT_SIGNAL_ID: Item<u64> = Item::new("next_signal_id");

// Index signals by subject for efficient lookup
pub const SIGNALS_BY_SUBJECT: Map<(&str, &str), Vec<u64>> = Map::new("signals_by_subject");
pub const SIGNALS_BY_SIGNALER: Map<&Addr, Vec<u64>> = Map::new("signals_by_signaler");
```

### Core Logic

```rust
// contracts/reputation-registry/src/contract.rs

fn execute_submit_signal(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    subject_type: SubjectType,
    subject_id: String,
    category: String,
    endorsement_level: u8,
    rationale_iri: Option<String>,
) -> Result<Response, ContractError> {
    let config = CONFIG.load(deps.storage)?;

    // Validate endorsement level
    if endorsement_level < 1 || endorsement_level > 5 {
        return Err(ContractError::InvalidEndorsementLevel {});
    }

    // Query signaler's staked amount from x/staking
    let stake = query_staked_amount(deps.as_ref(), &info.sender)?;

    // Verify minimum stake for category
    let min_stake = get_min_stake_for_category(&config, &category)?;
    if stake < min_stake {
        return Err(ContractError::InsufficientStake {
            required: min_stake,
            actual: stake,
        });
    }

    // Create signal
    let signal_id = NEXT_SIGNAL_ID.load(deps.storage).unwrap_or(1);
    let signal = ReputationSignal {
        id: signal_id,
        signaler: info.sender.clone(),
        subject_type: subject_type.clone(),
        subject_id: subject_id.clone(),
        category: category.clone(),
        endorsement_level,
        rationale_iri,
        stake_at_signal: stake,
        created_at: env.block.time,
        status: SignalStatus::Active,
    };

    SIGNALS.save(deps.storage, signal_id, &signal)?;
    NEXT_SIGNAL_ID.save(deps.storage, &(signal_id + 1))?;

    // Update indexes
    update_signal_indexes(deps.storage, &signal)?;

    // Recompute aggregated reputation
    recompute_aggregated_reputation(
        deps.storage,
        &env,
        &config,
        &subject_type,
        &subject_id,
        &category,
    )?;

    Ok(Response::new()
        .add_attribute("action", "submit_signal")
        .add_attribute("signal_id", signal_id.to_string())
        .add_attribute("subject", format!("{:?}:{}", subject_type, subject_id))
        .add_attribute("category", category)
        .add_attribute("endorsement", endorsement_level.to_string()))
}

fn recompute_aggregated_reputation(
    storage: &mut dyn Storage,
    env: &Env,
    config: &Config,
    subject_type: &SubjectType,
    subject_id: &str,
    category: &str,
) -> StdResult<()> {
    let subject_key = format!("{:?}", subject_type);
    let signal_ids = SIGNALS_BY_SUBJECT
        .may_load(storage, (&subject_key, subject_id))?
        .unwrap_or_default();

    let mut total_weighted_score = Uint128::zero();
    let mut total_weight = Uint128::zero();
    let mut signal_count = 0u32;

    for signal_id in signal_ids {
        let signal = SIGNALS.load(storage, signal_id)?;

        if signal.status != SignalStatus::Active || signal.category != category {
            continue;
        }

        // Calculate time decay
        let age_seconds = env.block.time.seconds() - signal.created_at.seconds();
        let half_life_seconds = config.decay_half_life_days * 86400;
        let decay_factor = calculate_decay(age_seconds, half_life_seconds);

        // Weight = stake * decay
        let weight = signal.stake_at_signal.multiply_ratio(decay_factor, 1000u128);

        // Score contribution = weight * endorsement_level
        let score_contribution = weight.multiply_ratio(
            Uint128::from(signal.endorsement_level as u128),
            Uint128::from(5u128),  // Normalize to 0-1
        );

        total_weighted_score = total_weighted_score.checked_add(score_contribution)?;
        total_weight = total_weight.checked_add(weight)?;
        signal_count += 1;
    }

    // Compute final score (0-1000)
    let score = if total_weight.is_zero() {
        Uint128::zero()
    } else {
        total_weighted_score.multiply_ratio(1000u128, total_weight)
    };

    let aggregated = AggregatedReputation {
        subject_type: subject_type.clone(),
        subject_id: subject_id.to_string(),
        category: category.to_string(),
        score,
        signal_count,
        last_updated: env.block.time,
    };

    AGGREGATED.save(storage, (&subject_key, subject_id, category), &aggregated)?;

    Ok(())
}

fn calculate_decay(age_seconds: u64, half_life_seconds: u64) -> u128 {
    // Approximate exponential decay: e^(-age/half_life)
    // Using: 1000 * 2^(-age/half_life) ≈ 1000 * (1/2)^(age/half_life)
    let half_lives = age_seconds / half_life_seconds;
    if half_lives >= 10 {
        return 1;  // Minimum decay factor
    }
    1000u128 >> half_lives  // Bit shift approximation
}
```

---

## CosmWasm Contract: Marketplace Curation (M011)

### Contract Interface

```rust
// contracts/marketplace-curation/src/msg.rs

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum ExecuteMsg {
    // Create a curated collection
    CreateCollection {
        name: String,
        description: String,
        criteria: CurationCriteria,
    },

    // Add batch to collection (curator only)
    AddToCollection {
        collection_id: u64,
        batch_denom: String,
    },

    // Remove batch from collection
    RemoveFromCollection {
        collection_id: u64,
        batch_denom: String,
    },

    // Update collection criteria
    UpdateCriteria {
        collection_id: u64,
        criteria: CurationCriteria,
    },

    // Submit quality score (agent only)
    SubmitQualityScore {
        batch_denom: String,
        score: u32,  // 0-1000
        confidence: u32,
        factors: QualityFactors,
    },

    // Feature a batch (agent recommendation)
    FeatureBatch {
        batch_denom: String,
        reason: String,
    },

    // Claim curator rewards
    ClaimRewards {
        collection_id: u64,
    },
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct CurationCriteria {
    pub min_project_reputation: Option<u32>,
    pub min_class_reputation: Option<u32>,
    pub allowed_credit_types: Vec<String>,
    pub allowed_jurisdictions: Vec<String>,
    pub min_vintage_year: Option<u32>,
    pub max_vintage_year: Option<u32>,
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]
pub struct QualityFactors {
    pub project_reputation: u32,
    pub class_reputation: u32,
    pub vintage_freshness: u32,
    pub verification_recency: u32,
    pub seller_reputation: u32,
    pub price_fairness: u32,
    pub additionality_confidence: u32,
}
```

---

## DAO DAO Integration: Arbiter DAO

### Instantiation Config

```json
{
  "name": "Regen Attestation Arbiter DAO",
  "description": "Resolves disputes for attestation bonds and service escrows",
  "image_url": "https://regen.network/arbiter-dao.png",
  "automatically_add_cw20s": false,
  "automatically_add_cw721s": false,
  "voting_module_instantiate_info": {
    "code_id": 123,
    "label": "arbiter_voting",
    "msg": {
      "token_info": {
        "existing": {
          "denom": "uregen"
        }
      },
      "unstaking_duration": {
        "time": 1209600
      }
    }
  },
  "proposal_modules_instantiate_info": [
    {
      "code_id": 124,
      "label": "arbiter_proposals",
      "msg": {
        "threshold": {
          "threshold_quorum": {
            "threshold": {
              "majority": {}
            },
            "quorum": {
              "percent": "0.15"
            }
          }
        },
        "max_voting_period": {
          "time": 604800
        },
        "min_voting_period": {
          "time": 86400
        },
        "allow_revoting": true,
        "close_proposal_on_execution_failure": true
      }
    }
  ]
}
```

---

## Summary

| Contract | Type | Language | Complexity |
|----------|------|----------|------------|
| x/ecocredit enhancement | Native Module | Go | Medium |
| attestation-bond | CosmWasm | Rust | High |
| service-escrow | CosmWasm | Rust | High |
| reputation-registry | CosmWasm | Rust | Medium |
| marketplace-curation | CosmWasm | Rust | Medium |
| arbiter-dao | DAO DAO | Config | Low |

**Total Lines of Code (estimated)**: ~3,500
**Dependencies**: cosmwasm-std 1.5+, cw-storage-plus, DAO DAO contracts
