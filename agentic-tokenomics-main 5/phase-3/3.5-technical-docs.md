# Phase 3.5: Technical Documentation

## Overview

This document provides comprehensive technical documentation for developers, operators, and integrators working with the Regen Agentic Tokenomics system.

---

## Architecture Reference

### System Components

```
┌─────────────────────────────────────────────────────────────────────────────────┐
│                        REGEN AGENTIC TOKENOMICS SYSTEM                          │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                  │
│  ┌────────────────────────────────────────────────────────────────────────┐     │
│  │                         USER INTERFACES                                 │     │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │     │
│  │  │ Discord  │  │ Twitter  │  │ Telegram │  │ Web App  │  │   CLI    │ │     │
│  │  └─────┬────┘  └─────┬────┘  └─────┬────┘  └─────┬────┘  └─────┬────┘ │     │
│  └────────┼─────────────┼─────────────┼─────────────┼─────────────┼──────┘     │
│           └─────────────┴─────────────┴──────┬──────┴─────────────┘            │
│                                              │                                  │
│  ┌───────────────────────────────────────────┴───────────────────────────┐     │
│  │                        AGENT LAYER (ElizaOS)                           │     │
│  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐        │     │
│  │  │ Registry        │  │ Governance      │  │ Market          │        │     │
│  │  │ Reviewer        │  │ Analyst         │  │ Monitor         │        │     │
│  │  │ (AGENT-001)     │  │ (AGENT-002)     │  │ (AGENT-003)     │        │     │
│  │  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘        │     │
│  │           │                    │                    │                  │     │
│  │  ┌────────┴────────────────────┴────────────────────┴────────┐        │     │
│  │  │              OODA Workflow Engine                          │        │     │
│  │  │  Observe → Orient → Decide → Act                          │        │     │
│  │  └───────────────────────────────────────────────────────────┘        │     │
│  └───────────────────────────────────────────────────────────────────────┘     │
│                                              │                                  │
│  ┌───────────────────────────────────────────┴───────────────────────────┐     │
│  │                    MCP INTEGRATION LAYER                               │     │
│  │  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐     │     │
│  │  │   KOI MCP        │  │  LEDGER MCP      │  │  TX BUILDER      │     │     │
│  │  │   (Knowledge)    │  │  (On-Chain)      │  │  (Transactions)  │     │     │
│  │  └────────┬─────────┘  └────────┬─────────┘  └────────┬─────────┘     │     │
│  └───────────┼─────────────────────┼─────────────────────┼───────────────┘     │
│              │                     │                     │                      │
│  ┌───────────┴─────────────────────┴─────────────────────┴───────────────┐     │
│  │                        DATA LAYER                                      │     │
│  │  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌───────────┐  │     │
│  │  │ Regen Ledger │  │ Apache Jena  │  │ PostgreSQL   │  │  Redis    │  │     │
│  │  │ (Blockchain) │  │ (KOI Graph)  │  │ (Agent State)│  │ (Cache)   │  │     │
│  │  └──────────────┘  └──────────────┘  └──────────────┘  └───────────┘  │     │
│  └───────────────────────────────────────────────────────────────────────┘     │
│                                                                                  │
│  ┌───────────────────────────────────────────────────────────────────────┐     │
│  │                    SMART CONTRACT LAYER                                │     │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │     │
│  │  │ Attestation │  │ Service     │  │ Reputation  │  │ Marketplace │   │     │
│  │  │ Bond (M008) │  │ Escrow(M009)│  │ Signal(M010)│  │ Curation    │   │     │
│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │     │
│  └───────────────────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────────────┘
```

### Component Responsibilities

| Component | Primary Function | Key Dependencies |
|-----------|-----------------|------------------|
| ElizaOS Runtime | Agent execution, workflow orchestration | MCP clients, PostgreSQL |
| KOI MCP | Knowledge retrieval, entity resolution | Apache Jena, Qdrant |
| Ledger MCP | On-chain data access, state queries | Regen Ledger RPC |
| TX Builder | Transaction construction, simulation | Regen Ledger RPC |
| Attestation Bond | Data quality assurance bonding | DAO DAO (arbiter) |
| Service Escrow | Payment protection for services | DAO DAO (arbiter) |
| Reputation Registry | Trust signal aggregation | Staking module |
| Marketplace Curation | Credit quality signaling | Reputation Registry |

---

## API Reference

### Agent API Endpoints

```yaml
# Agent Management API
openapi: 3.0.0
info:
  title: Regen Agent API
  version: 1.0.0

paths:
  /api/agents:
    get:
      summary: List all agents
      responses:
        200:
          description: List of agents
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Agent'

  /api/agents/{agentId}/status:
    get:
      summary: Get agent status
      parameters:
        - name: agentId
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: Agent status
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AgentStatus'

  /api/agents/{agentId}/message:
    post:
      summary: Send message to agent
      parameters:
        - name: agentId
          in: path
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                message:
                  type: string
                context:
                  type: object
      responses:
        200:
          description: Agent response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AgentResponse'

  /api/agents/{agentId}/decisions:
    get:
      summary: Get agent decision history
      parameters:
        - name: agentId
          in: path
          required: true
          schema:
            type: string
        - name: limit
          in: query
          schema:
            type: integer
            default: 20
        - name: offset
          in: query
          schema:
            type: integer
            default: 0
        - name: decision_type
          in: query
          schema:
            type: string
            enum: [RECOMMEND, ESCALATE, ALERT, PROPOSE]
      responses:
        200:
          description: Decision history
          content:
            application/json:
              schema:
                type: object
                properties:
                  decisions:
                    type: array
                    items:
                      $ref: '#/components/schemas/Decision'
                  pagination:
                    $ref: '#/components/schemas/Pagination'

  /api/workflows/{executionId}:
    get:
      summary: Get workflow execution details
      parameters:
        - name: executionId
          in: path
          required: true
          schema:
            type: string
      responses:
        200:
          description: Workflow execution
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/WorkflowExecution'

  /api/escalations:
    get:
      summary: List pending escalations
      parameters:
        - name: status
          in: query
          schema:
            type: string
            enum: [pending, resolved, expired]
      responses:
        200:
          description: Escalation list
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Escalation'

    post:
      summary: Resolve escalation
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                escalation_id:
                  type: string
                resolution:
                  type: string
                  enum: [approve, reject, modify]
                rationale:
                  type: string
      responses:
        200:
          description: Resolution recorded

components:
  schemas:
    Agent:
      type: object
      properties:
        id:
          type: string
        name:
          type: string
        type:
          type: string
        status:
          type: string
          enum: [active, paused, error]

    AgentStatus:
      type: object
      properties:
        agent_id:
          type: string
        status:
          type: string
        uptime_seconds:
          type: integer
        last_activity:
          type: string
          format: date-time
        metrics:
          type: object
          properties:
            decisions_today:
              type: integer
            escalations_today:
              type: integer
            avg_confidence:
              type: number

    AgentResponse:
      type: object
      properties:
        response:
          type: string
        action_taken:
          type: string
        confidence:
          type: number
        sources:
          type: array
          items:
            type: string

    Decision:
      type: object
      properties:
        id:
          type: string
        agent_id:
          type: string
        decision_type:
          type: string
        subject_type:
          type: string
        subject_id:
          type: string
        decision:
          type: string
        confidence:
          type: number
        rationale:
          type: string
        evidence:
          type: object
        created_at:
          type: string
          format: date-time

    WorkflowExecution:
      type: object
      properties:
        execution_id:
          type: string
        workflow_id:
          type: string
        agent_id:
          type: string
        status:
          type: string
          enum: [running, completed, failed, escalated]
        observations:
          type: array
        orientation:
          type: object
        decision:
          type: object
        actions:
          type: array
        started_at:
          type: string
          format: date-time
        completed_at:
          type: string
          format: date-time

    Escalation:
      type: object
      properties:
        id:
          type: string
        agent_id:
          type: string
        workflow_id:
          type: string
        reason:
          type: string
        context:
          type: object
        created_at:
          type: string
          format: date-time
        status:
          type: string
          enum: [pending, resolved, expired]

    Pagination:
      type: object
      properties:
        total:
          type: integer
        limit:
          type: integer
        offset:
          type: integer
```

### Smart Contract Interfaces

```rust
// Attestation Bond Contract Messages

/// Instantiate message
pub struct InstantiateMsg {
    /// Contract administrator
    pub admin: String,
    /// DAO that resolves disputes
    pub arbiter_dao: String,
    /// Minimum bond amount in uregen
    pub min_bond: Uint128,
    /// Time bond is locked after activation (seconds)
    pub lock_period: u64,
    /// Time window for challenges (seconds)
    pub challenge_window: u64,
}

/// Execute messages
pub enum ExecuteMsg {
    /// Create a new attestation with bond
    CreateBond {
        attestation_type: String,
        attestation_iri: String,
        beneficiary: Option<String>,
    },
    /// Challenge an attestation
    Challenge {
        attestation_id: u64,
        evidence_iri: String,
    },
    /// Release bond after lock period (attester only)
    ReleaseBond {
        attestation_id: u64,
    },
    /// Resolve challenge (arbiter only)
    ResolveChallenge {
        attestation_id: u64,
        slash: bool,
        slash_recipient: Option<String>,
    },
    /// Update contract configuration (admin only)
    UpdateConfig {
        admin: Option<String>,
        arbiter_dao: Option<String>,
        min_bond: Option<Uint128>,
        lock_period: Option<u64>,
        challenge_window: Option<u64>,
    },
}

/// Query messages
pub enum QueryMsg {
    /// Get contract configuration
    Config {},
    /// Get attestation by ID
    Attestation { id: u64 },
    /// List attestations with filters
    Attestations {
        attester: Option<String>,
        status: Option<BondStatus>,
        start_after: Option<u64>,
        limit: Option<u32>,
    },
    /// Get attestations by address
    AttestationsByAddress {
        address: String,
        start_after: Option<u64>,
        limit: Option<u32>,
    },
}

// Response types
pub struct ConfigResponse {
    pub admin: Addr,
    pub arbiter_dao: Addr,
    pub min_bond: Uint128,
    pub lock_period: u64,
    pub challenge_window: u64,
    pub next_attestation_id: u64,
}

pub struct AttestationResponse {
    pub id: u64,
    pub attester: Addr,
    pub attestation_type: String,
    pub attestation_iri: String,
    pub beneficiary: Option<Addr>,
    pub bond: Coin,
    pub status: BondStatus,
    pub bonded_at: Timestamp,
    pub activated_at: Option<Timestamp>,
    pub lock_expires_at: Timestamp,
    pub challenge_window_closes_at: Timestamp,
    pub challenger: Option<Addr>,
    pub challenge_evidence_iri: Option<String>,
}
```

---

## Configuration Reference

### Agent Configuration

```yaml
# config/agent.yaml

# Agent identity
agent:
  id: "agent-001"
  name: "RegenRegistryReviewer"
  type: "registry_reviewer"

# Model configuration
model:
  provider: "anthropic"
  model: "claude-sonnet-4-20250514"
  temperature: 0.3
  max_tokens: 4096

# MCP connections
mcp:
  ledger:
    url: "${LEDGER_MCP_URL}"
    api_key: "${LEDGER_MCP_API_KEY}"
    timeout: 30000
    retry:
      max_attempts: 3
      backoff_ms: 1000

  koi:
    url: "${KOI_MCP_URL}"
    api_key: "${KOI_MCP_API_KEY}"
    timeout: 30000
    retry:
      max_attempts: 3
      backoff_ms: 1000

# Database
database:
  url: "${DATABASE_URL}"
  pool_size: 10

# Redis
redis:
  url: "${REDIS_URL}"
  prefix: "agent:001"

# Governance settings
governance:
  authority_level: 2
  escalation_threshold: 0.7
  human_review_window_hours: 24
  can_propose: true
  can_execute: false

# Rate limits
rate_limits:
  llm_requests_per_minute: 20
  mcp_requests_per_minute: 100
  decisions_per_hour: 50

# Logging
logging:
  level: "info"
  format: "json"
  audit_enabled: true
  audit_destination: "koi"
```

### Docker Environment

```bash
# .env.production

# Agent settings
AGENT_CHARACTER=registry-reviewer

# Model API
ANTHROPIC_API_KEY=sk-ant-...

# MCP endpoints
LEDGER_MCP_URL=https://ledger-mcp.regen.network
LEDGER_MCP_API_KEY=...
KOI_MCP_URL=https://koi-mcp.regen.network
KOI_MCP_API_KEY=...

# Database
DATABASE_URL=postgresql://user:pass@postgres:5432/agents

# Redis
REDIS_URL=redis://redis:6379

# Blockchain
REGEN_NODE_URL=https://rpc.regen.network
REGEN_CHAIN_ID=regen-1

# Social (optional)
DISCORD_BOT_TOKEN=...
TWITTER_API_KEY=...
TWITTER_API_SECRET=...
TWITTER_ACCESS_TOKEN=...
TWITTER_ACCESS_SECRET=...
```

### Kubernetes ConfigMap

```yaml
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-config
  namespace: regen-agentic
data:
  agent.yaml: |
    agent:
      type: registry_reviewer
    governance:
      authority_level: 2
      escalation_threshold: 0.7
    rate_limits:
      llm_requests_per_minute: 20
      mcp_requests_per_minute: 100

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: contract-addresses
  namespace: regen-agentic
data:
  attestation_bond: "regen1..."
  service_escrow: "regen1..."
  reputation_registry: "regen1..."
  marketplace_curation: "regen1..."
```

---

## Operations Guide

### Deployment Procedures

#### Initial Deployment

```bash
#!/bin/bash
# deploy.sh - Initial deployment

set -e

# 1. Deploy smart contracts
echo "Deploying smart contracts..."
cd contracts

# Build contracts
cargo build --release --target wasm32-unknown-unknown
docker run --rm -v "$(pwd)":/code \
  cosmwasm/workspace-optimizer:0.14.0

# Store code on chain
ATTESTATION_CODE_ID=$(regen tx wasm store artifacts/attestation_bond.wasm \
  --from deployer --gas auto --gas-adjustment 1.3 -y \
  --output json | jq -r '.logs[0].events[] | select(.type=="store_code") | .attributes[] | select(.key=="code_id") | .value')

# Instantiate contracts
regen tx wasm instantiate $ATTESTATION_CODE_ID \
  '{"admin":"regen1admin...","arbiter_dao":"regen1dao...","min_bond":"100000000","lock_period":"2592000","challenge_window":"604800"}' \
  --label "attestation-bond-v1" \
  --admin regen1admin... \
  --from deployer -y

# 2. Deploy agent infrastructure
echo "Deploying agent infrastructure..."
cd ../k8s

# Create namespace
kubectl create namespace regen-agentic

# Deploy secrets
kubectl create secret generic agent-secrets \
  --from-env-file=../.env.production \
  -n regen-agentic

# Deploy configmaps
kubectl apply -f configmap.yaml

# Deploy databases
kubectl apply -f postgres.yaml
kubectl apply -f redis.yaml

# Wait for databases
kubectl wait --for=condition=ready pod -l app=postgres -n regen-agentic --timeout=120s
kubectl wait --for=condition=ready pod -l app=redis -n regen-agentic --timeout=60s

# Run database migrations
kubectl run migrations --rm -i --tty \
  --image=regen/agent:latest \
  --env="DATABASE_URL=$DATABASE_URL" \
  -- npm run migrate

# Deploy agents
kubectl apply -f agent-deployment.yaml

# 3. Verify deployment
echo "Verifying deployment..."
kubectl get pods -n regen-agentic
kubectl logs -l app=regen-agents -n regen-agentic --tail=50

echo "Deployment complete!"
```

#### Rolling Update

```bash
#!/bin/bash
# update.sh - Rolling update

set -e

VERSION=$1

if [ -z "$VERSION" ]; then
  echo "Usage: ./update.sh <version>"
  exit 1
fi

# 1. Update container image
kubectl set image deployment/regen-agents \
  registry-reviewer=regen/agent:$VERSION \
  governance-analyst=regen/agent:$VERSION \
  market-monitor=regen/agent:$VERSION \
  -n regen-agentic

# 2. Watch rollout
kubectl rollout status deployment/regen-agents -n regen-agentic

# 3. Verify health
kubectl get pods -n regen-agentic
curl -s http://agents.regen.network/health | jq .

echo "Update to $VERSION complete!"
```

### Monitoring Setup

```yaml
# k8s/monitoring.yaml

# Prometheus ServiceMonitor
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: regen-agents
  namespace: regen-agentic
spec:
  selector:
    matchLabels:
      app: regen-agents
  endpoints:
    - port: metrics
      interval: 30s
      path: /metrics

---
# Grafana Dashboard ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: agent-dashboard
  namespace: monitoring
  labels:
    grafana_dashboard: "1"
data:
  agent-dashboard.json: |
    {
      "title": "Regen Agents",
      "panels": [
        {
          "title": "Decision Rate",
          "type": "graph",
          "targets": [
            {
              "expr": "rate(agent_decisions_total[5m])",
              "legendFormat": "{{agent}}"
            }
          ]
        },
        {
          "title": "Escalation Rate",
          "type": "graph",
          "targets": [
            {
              "expr": "rate(agent_escalations_total[5m])",
              "legendFormat": "{{agent}}"
            }
          ]
        },
        {
          "title": "Average Confidence",
          "type": "gauge",
          "targets": [
            {
              "expr": "avg(agent_decision_confidence)",
              "legendFormat": "Confidence"
            }
          ]
        },
        {
          "title": "MCP Latency",
          "type": "heatmap",
          "targets": [
            {
              "expr": "histogram_quantile(0.95, rate(mcp_request_duration_seconds_bucket[5m]))",
              "legendFormat": "p95"
            }
          ]
        }
      ]
    }
```

### Alerting Rules

```yaml
# k8s/alerts.yaml

apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: agent-alerts
  namespace: regen-agentic
spec:
  groups:
    - name: agent-health
      rules:
        - alert: AgentDown
          expr: up{job="regen-agents"} == 0
          for: 5m
          labels:
            severity: critical
          annotations:
            summary: "Agent {{ $labels.agent }} is down"
            description: "Agent has been unreachable for more than 5 minutes"

        - alert: HighEscalationRate
          expr: rate(agent_escalations_total[1h]) > 10
          for: 15m
          labels:
            severity: warning
          annotations:
            summary: "High escalation rate for {{ $labels.agent }}"
            description: "Escalation rate exceeds 10/hour"

        - alert: LowConfidenceAverage
          expr: avg_over_time(agent_decision_confidence[1h]) < 0.6
          for: 30m
          labels:
            severity: warning
          annotations:
            summary: "Low average confidence for {{ $labels.agent }}"
            description: "Average confidence below 0.6 for 30 minutes"

        - alert: MCPLatencyHigh
          expr: histogram_quantile(0.95, rate(mcp_request_duration_seconds_bucket[5m])) > 2
          for: 10m
          labels:
            severity: warning
          annotations:
            summary: "High MCP latency"
            description: "95th percentile MCP latency exceeds 2 seconds"

        - alert: DecisionBacklog
          expr: agent_pending_decisions > 100
          for: 15m
          labels:
            severity: warning
          annotations:
            summary: "Decision backlog for {{ $labels.agent }}"
            description: "More than 100 pending decisions"
```

### Runbook: Common Operations

#### Pause an Agent

```bash
# Pause agent by scaling to 0
kubectl scale deployment regen-agents --replicas=0 -n regen-agentic

# Or pause specific container
kubectl patch deployment regen-agents -n regen-agentic --type='json' \
  -p='[{"op": "add", "path": "/spec/template/spec/containers/0/env/-", "value": {"name": "AGENT_PAUSED", "value": "true"}}]'
```

#### Force Escalation

```bash
# Mark all pending decisions as escalated
curl -X POST http://agents.regen.network/api/admin/force-escalate \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"agent_id": "agent-001", "reason": "Manual escalation for review"}'
```

#### Rotate API Keys

```bash
# Generate new key
NEW_KEY=$(openssl rand -base64 32)

# Update secret
kubectl patch secret agent-secrets -n regen-agentic \
  --type='json' \
  -p="[{\"op\": \"replace\", \"path\": \"/data/LEDGER_MCP_API_KEY\", \"value\": \"$(echo -n $NEW_KEY | base64)\"}]"

# Restart agents to pick up new key
kubectl rollout restart deployment/regen-agents -n regen-agentic
```

#### Database Backup

```bash
# Manual backup
kubectl exec -n regen-agentic postgres-0 -- \
  pg_dump -U postgres agents > backup-$(date +%Y%m%d).sql

# Automated backup (CronJob)
apiVersion: batch/v1
kind: CronJob
metadata:
  name: postgres-backup
  namespace: regen-agentic
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
            - name: backup
              image: postgres:16
              command:
                - /bin/sh
                - -c
                - pg_dump -h postgres -U postgres agents | gzip > /backups/backup-$(date +%Y%m%d).sql.gz
              volumeMounts:
                - name: backups
                  mountPath: /backups
          volumes:
            - name: backups
              persistentVolumeClaim:
                claimName: backup-pvc
          restartPolicy: OnFailure
```

---

## Troubleshooting Guide

### Common Issues

#### Agent Not Responding

```yaml
symptom: Agent not responding to messages
possible_causes:
  - Agent container crashed
  - MCP connection failed
  - Database connection pool exhausted
  - Rate limit exceeded

diagnosis:
  - Check pod status: kubectl get pods -n regen-agentic
  - Check logs: kubectl logs -l app=regen-agents -n regen-agentic --tail=100
  - Check MCP connectivity: curl -v http://ledger-mcp:3001/health
  - Check database: psql $DATABASE_URL -c "SELECT count(*) FROM pg_stat_activity"

resolution:
  container_crash:
    - Check OOM: kubectl describe pod <pod-name> -n regen-agentic
    - Increase memory limits if needed
    - Check for infinite loops in workflow

  mcp_connection:
    - Verify MCP server status
    - Check network policies
    - Verify API key not expired

  database_pool:
    - Increase pool size in config
    - Check for connection leaks
    - Restart agent to clear connections
```

#### High Escalation Rate

```yaml
symptom: Agent escalating more than 20% of decisions
possible_causes:
  - Threshold too high
  - Input data quality issues
  - Model degradation
  - New edge cases

diagnosis:
  - Review escalated decisions: SELECT * FROM agent_decisions WHERE decision = 'ESCALATE' ORDER BY created_at DESC LIMIT 50
  - Analyze confidence distribution: SELECT decision, AVG(confidence) FROM agent_decisions GROUP BY decision
  - Check input data: Review observations in workflow_executions

resolution:
  threshold_adjustment:
    - Temporarily lower threshold
    - Analyze false escalations
    - Retrain if needed

  data_quality:
    - Check MCP response quality
    - Verify KOI index freshness
    - Add input validation

  new_edge_cases:
    - Document edge cases
    - Update prompts
    - Add handling logic
```

#### Contract Transaction Failures

```yaml
symptom: Smart contract transactions failing
possible_causes:
  - Insufficient gas
  - State precondition not met
  - Signature issues
  - Network congestion

diagnosis:
  - Check transaction error: regen query tx <hash>
  - Simulate transaction: regen tx wasm execute ... --dry-run
  - Check contract state: regen query wasm contract-state smart <contract> '{...}'

resolution:
  gas_issues:
    - Increase gas limit
    - Use gas auto-adjustment
    - Check for infinite loops in contract

  precondition_failures:
    - Verify state before transaction
    - Add proper error handling
    - Check timing conditions (lock periods, windows)

  signature_issues:
    - Verify key is correct
    - Check account sequence
    - Ensure proper key permissions
```

---

## Glossary

| Term | Definition |
|------|------------|
| Agent | Autonomous software entity that observes, reasons, and acts on behalf of the system |
| Attestation | A cryptographically signed statement about data or state |
| Bond | Tokens locked as collateral to guarantee behavior |
| CosmWasm | WebAssembly smart contract platform for Cosmos SDK chains |
| Escalation | Process of elevating a decision to human review |
| KOI | Knowledge Organization Infrastructure - Regen's knowledge graph |
| Layer 1-4 | Governance automation levels from fully automated to constitutional |
| MCP | Model Context Protocol - standard for AI model data access |
| OODA | Observe-Orient-Decide-Act workflow pattern |
| Slashing | Penalty mechanism that confiscates bonded tokens |

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0.0 | 2026-02-04 | Initial specification |
